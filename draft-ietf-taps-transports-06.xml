<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.26 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC0791 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0791.xml">
<!ENTITY RFC0768 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0768.xml">
<!ENTITY RFC0793 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0793.xml">
<!ENTITY RFC0896 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0896.xml">
<!ENTITY RFC1122 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1122.xml">
<!ENTITY RFC1191 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1191.xml">
<!ENTITY RFC1981 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1981.xml">
<!ENTITY RFC2018 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2018.xml">
<!ENTITY RFC2045 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2045.xml">
<!ENTITY RFC2460 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2460.xml">
<!ENTITY RFC2617 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2617.xml">
<!ENTITY RFC3168 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3168.xml">
<!ENTITY RFC3205 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3205.xml">
<!ENTITY RFC3390 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3390.xml">
<!ENTITY RFC3436 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3436.xml">
<!ENTITY RFC3452 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3452.xml">
<!ENTITY RFC3758 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3758.xml">
<!ENTITY RFC3828 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3828.xml">
<!ENTITY RFC4324 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4324.xml">
<!ENTITY RFC4336 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4336.xml">
<!ENTITY RFC4340 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4340.xml">
<!ENTITY RFC4341 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4341.xml">
<!ENTITY RFC4342 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4342.xml">
<!ENTITY RFC4614 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4614.xml">
<!ENTITY RFC4654 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4654.xml">
<!ENTITY RFC4820 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4820.xml">
<!ENTITY RFC4821 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4821.xml">
<!ENTITY RFC4895 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4895.xml">
<!ENTITY RFC4960 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4960.xml">
<!ENTITY RFC5061 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5061.xml">
<!ENTITY RFC5097 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5097.xml">
<!ENTITY RFC5246 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC5348 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5348.xml">
<!ENTITY RFC5405 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5405.xml">
<!ENTITY RFC5595 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5595.xml">
<!ENTITY RFC5596 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5596.xml">
<!ENTITY RFC5662 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5662.xml">
<!ENTITY RFC5672 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5672.xml">
<!ENTITY RFC5740 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5740.xml">
<!ENTITY RFC6773 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6773.xml">
<!ENTITY RFC5925 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5925.xml">
<!ENTITY RFC5681 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5681.xml">
<!ENTITY RFC6083 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6083.xml">
<!ENTITY RFC6093 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6093.xml">
<!ENTITY RFC6525 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6525.xml">
<!ENTITY RFC6546 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6546.xml">
<!ENTITY RFC6298 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6298.xml">
<!ENTITY RFC6347 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6347.xml">
<!ENTITY RFC6356 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6356.xml">
<!ENTITY RFC6455 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6455.xml">
<!ENTITY RFC6458 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6458.xml">
<!ENTITY RFC6691 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6691.xml">
<!ENTITY RFC6824 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6824.xml">
<!ENTITY RFC6897 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6897.xml">
<!ENTITY RFC6935 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6935.xml">
<!ENTITY RFC6936 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6936.xml">
<!ENTITY RFC6951 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6951.xml">
<!ENTITY RFC7053 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7053.xml">
<!ENTITY RFC7230 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml">
<!ENTITY RFC7231 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7231.xml">
<!ENTITY RFC7232 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7232.xml">
<!ENTITY RFC7233 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7233.xml">
<!ENTITY RFC7234 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7234.xml">
<!ENTITY RFC7235 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7235.xml">
<!ENTITY RFC7301 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7301.xml">
<!ENTITY RFC7323 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7323.xml">
<!ENTITY RFC7457 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7457.xml">
<!ENTITY RFC7525 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7525.xml">
<!ENTITY RFC7540 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7540.xml">
<!ENTITY I-D.ietf-aqm-ecn-benefits SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-aqm-ecn-benefits.xml">
<!ENTITY I-D.ietf-tsvwg-sctp-dtls-encaps SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-tsvwg-sctp-dtls-encaps.xml">
<!ENTITY I-D.ietf-tsvwg-sctp-prpolicies SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-tsvwg-sctp-prpolicies.xml">
<!ENTITY I-D.ietf-tsvwg-sctp-ndata SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-tsvwg-sctp-ndata.xml">
<!ENTITY I-D.ietf-tsvwg-natsupp SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-tsvwg-natsupp.xml">
]>

<?rfc toc="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-taps-transports-06" category="info">

  <front>
    <title abbrev="TAPS Transports">Services provided by IETF transport protocols and congestion control mechanisms</title>

    <author initials="G." surname="Fairhurst" fullname="Godred Fairhurst" role="editor">
      <organization>University of Aberdeen</organization>
      <address>
        <postal>
          <street>School of Engineering, Fraser Noble Building</street>
          <city>Aberdeen AB24 3UE</city>
        </postal>
        <email>gorry@erg.abdn.ac.uk</email>
      </address>
    </author>
    <author initials="B." surname="Trammell" fullname="Brian Trammell" role="editor">
      <organization>ETH Zurich</organization>
      <address>
        <postal>
          <street>Gloriastrasse 35</street>
          <city>8092 Zurich</city>
          <country>Switzerland</country>
        </postal>
        <email>ietf@trammell.ch</email>
      </address>
    </author>
    <author initials="M." surname="Kuehlewind" fullname="Mirja Kuehlewind" role="editor">
      <organization>ETH Zurich</organization>
      <address>
        <postal>
          <street>Gloriastrasse 35</street>
          <city>8092 Zurich</city>
          <country>Switzerland</country>
        </postal>
        <email>mirja.kuehlewind@tik.ee.ethz.ch</email>
      </address>
    </author>

    <date year="2015" month="July" day="6"/>

    
    
    

    <abstract>


<t>This document describes services provided by existing IETF protocols and
congestion control mechanisms.  It is designed to help application and
network stack programmers and to inform the work of the IETF TAPS Working
Group.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Most Internet applications make use of the Transport Services provided by
TCP (a reliable, in-order stream protocol) or UDP (an unreliable datagram
protocol). We use the term “Transport Service” to mean the end-to-end
service provided to an application by the transport layer. That service
can only be provided correctly if information about the intended usage is
supplied from the application. The application may determine this
information at design time, compile time, or run time, and may include
guidance on whether a feature is required, a preference by the
application, or something in between. Examples of features of Transport
Services are reliable delivery, ordered delivery, content privacy to
in-path devices, integrity protection, and minimal latency.</t>

<t>The IETF has defined a wide variety of transport protocols beyond TCP and
UDP, including SCTP, DCCP, MP-TCP, and UDP-Lite. Transport services
may be provided directly by these transport protocols, or layered on top
of them using protocols such as WebSockets (which runs over TCP), RTP
(over TCP or UDP) or WebRTC data channels (which run over SCTP over DTLS
over UDP or TCP). Services built on top of UDP or UDP-Lite typically also
need to specify additional mechanisms, including a congestion control
mechanism (such as a windowed congestion control, TFRC or LEDBAT
congestion control mechanism).  This extends the set of available
Transport Services beyond those provided to applications by TCP and UDP.</t>

<t>Transport protocols can also be differentiated by the features of the
services they provide: for instance, SCTP offers a message-based service
providing full or partial reliability and allowing to minimize the head of line
blocking due to the support of unordered and unordered message delivery within
multiple streams, UDP-Lite provides partial integrity protection, and LEDBAT
can provide low-priority “scavenger” communication.</t>

</section>
<section anchor="terminology" title="Terminology">

<t>The following terms are defined throughout this document, and in
subsequent documents produced by TAPS describing the composition and
decomposition of transport services.</t>

<t>[EDITOR’S NOTE: we may want to add definitions for the different kinds of
interfaces that are important here.]</t>

<t><list style="hanging">
  <t hangText='Transport Service Feature:'>
  a specific end-to-end feature that a transport service provides to its
clients. Examples include confidentiality, reliable delivery, ordered
delivery, message-versus-stream orientation, etc.</t>
  <t hangText='Transport Service:'>
  a set of transport service features, without an association to any given
framing protocol, which provides a complete service to an application.</t>
  <t hangText='Transport Protocol:'>
  an implementation that provides one or more different transport services
using a specific framing and header format on the wire.</t>
  <t hangText='Transport Protocol Component:'>
  an implementation of a transport service feature within a protocol.</t>
  <t hangText='Transport Service Instance:'>
  an arrangement of transport protocols with a selected set of features
and configuration parameters that implements a single transport service,
e.g. a protocol stack (RTP over UDP).</t>
  <t hangText='Application:'>
  an entity that uses the transport layer for end-to-end delivery data
across the network (this may also be an upper layer protocol or tunnel
encapsulation).</t>
</list></t>

</section>
<section anchor="existing-transport-protocols" title="Existing Transport Protocols">

<t>This section provides a list of known IETF transport protocol and
transport protocol frameworks.</t>

<t>[EDITOR’S NOTE: Contributions to the subsections below are welcome]</t>

<section anchor="transport-control-protocol-tcp" title="Transport Control Protocol (TCP)">

<t>TCP is an IETF standards track transport protocol.
<xref target="RFC0793"/> introduces TCP as follows: “The
Transmission Control Protocol (TCP) is intended for use as a highly
reliable host-to-host protocol between hosts
in packet-switched computer communication networks, and in interconnected
systems of such networks.” Since its introduction, TCP has become the
default connection-oriented,
stream-based transport protocol in the Internet. It is widely implemented
by endpoints and
widely used by common applications.</t>

<section anchor="protocol-description" title="Protocol Description">

<t>TCP is a connection-oriented protocol, providing a three way handshake to
allow a client and server to set up a connection, and mechanisms for orderly
completion and immediate teardown of a connection. TCP is defined by a family
of RFCs <xref target="RFC4614"/>.</t>

<t>TCP provides multiplexing to multiple sockets on each host using port numbers.
An active TCP session is identified by its four-tuple of local and remote IP
addresses and local port and remote port numbers. The destination port during
connection setup has a different role as it is often used to indicate the
requested service.</t>

<t>TCP partitions a continuous stream of bytes into segments, sized to fit in IP
packets. ICMP-based PathMTU discovery <xref target="RFC1191"/><xref target="RFC1981"/> as well as
Packetization Layer Path MTU Discovery (PMTUD) <xref target="RFC4821"/> are supported.</t>

<t>Each byte in the stream is identified by a sequence number. The sequence
number is used to order segments on receipt, to identify segments in
acknowledgments, and to detect unacknowledged segments for retransmission.
This is the basis of TCP’s reliable, ordered delivery of data in a stream. TCP
Selective Acknowledgment <xref target="RFC2018"/> extends this mechanism by making it
possible to identify missing segments more precisely, reducing spurious
retransmission.</t>

<t>Receiver flow control is provided by a sliding window: limiting the amount of
unacknowledged data that can be outstanding at a given time. The window scale
option <xref target="RFC7323"/> allows a receiver to use windows greater than 64KB.</t>

<t>All TCP senders provide Congestion Control: This uses a separate window, where
each time congestion is detected, this congestion window is reduced. A
receiver detects congestion using one of three mechanisms: A retransmission
timer, detection of loss (interpreted as a congestion signal), or Explicit
Congestion Notification (ECN) <xref target="RFC3168"/> to provide early signaling (see
<xref target="I-D.ietf-aqm-ecn-benefits"/>)</t>

<t>A TCP protocol instance can be extended <xref target="RFC4614"/> and tuned. Some features
are sender-side only, requiring no negotiation with the receiver; some are
receiver-side only, some are explicitly negotiated during connection setup.</t>

<t>By default, TCP segment partitioning uses Nagle’s algorithm <xref target="RFC0896"/> to
buffer data at the sender into large segments, potentially incurring
sender-side buffering delay; this algorithm can be disabled by the sender to
transmit more immediately, e.g. to enable smoother interactive sessions.</t>

<t>[EDITOR’S NOTE: add URGENT and PUSH flag (note <xref target="RFC6093"/> says SHOULD NOT use
due to the range of TCP implementations that process TCP urgent indications
differently.) ]</t>

<t>A checksum provides an Integrity Check and is mandatory across the entire
packet. The TCP checksum does not support partial corruption protection as in
DCCP/UDP-Lite). This check protects from misdelivery of data corrupted data,
but is relatively weak, and applications that require end to end integrity of
data are recommended to include a stronger integrity check of their payload
data.</t>

<t>A TCP service is unicast.</t>

</section>
<section anchor="interface-description" title="Interface description">

<t>A User/TCP Interface is defined in <xref target="RFC0793"/> providing six user commands:
Open, Send, Receive, Close, Status. This interface does not describe
configuration of TCP options or parameters beside use of the PUSH and URGENT
flags.</t>

<t>In API implementations derived from the BSD Sockets API, TCP sockets are
created using the <spanx style="verb">SOCK_STREAM</spanx> socket type.</t>

<t>The features used by a protocol instance may be set and tuned via this API.</t>

<t>(more on the API goes here)</t>

</section>
<section anchor="transport-protocol-components" title="Transport Protocol Components">

<t>The transport protocol components provided by TCP (new version) are:</t>

<t>[EDITOR’S NOTE: discussion of how to map this to features and TAPS: what does the higher
layer need to decide? what can the transport layer decide based on global
settings? what must the transport layer decide based on network
characteristics?]</t>

<t><list style="symbols">
  <t>Connection-oriented bidirectional communication using three-way handshake connection setup with feature negotiation and an explicit distinction between passive and active open: This implies both unicast addressing and a guarantee of return routability.</t>
  <t>Single stream-oriented transmission: The stream abstraction atop the datagram service provided by IP is implemented by dividing the stream into segments.</t>
  <t>Limited control over segment transmission scheduling (Nagle’s algorithm): This allows for delay minimization in interactive applications by preventing the transport to add additional delays (by deactivating Nagle’s algorithm).</t>
  <t>Port multiplexing, with application-to-port mapping during connection setup: Note that in the presence of network address and port translation (NAPT), TCP ports are in effect part of the endpoint address for forwarding purposes.</t>
  <t>Full reliability using (S)ACK- and RTO-based loss detection and retransmissions: Loss is sensed using duplicated ACKs (“fast retransmit”), which places a lower bound on	the delay inherent in this approach to reliability. The retransmission timeout determines the upper bound on the delay (expect if also exponential back-off is performed). The use of selective acknowlegdements further reduces the latency for retransmissions if multiple packets are lost during one congestion event.</t>
  <t>Error detection based on a checksum covering the network and transport headers as well as payload: Packets that are detected as corrupted are dropped, relying on the reliability mechanism	to retransmit them.</t>
  <t>Window-based flow control, with receiver-side window management and signaling of available window: Scaling the flow control window beyond 64kB requires the use of an optional feature,	which has performance implications in environments where this option is not supported; this can be the case either if the receiver does not implement window scaling or if a network node on the path strips the window scaling option.</t>
  <t>Window-based congestion control reacting to loss, delay, retransmission timeout, or an explicit congestion signal (ECN): Most commonly used is a loss signal from the reliability component’s retransmission mechanism. TCP reacts to a congestion signal by reducing the size of the congestion window; retransmission timeout is generally handled with a larger reaction than other signals.</t>
</list></t>

</section>
</section>
<section anchor="multipath-tcp-mptcp" title="Multipath TCP (MPTCP)">

<t>Multipath TCP <xref target="RFC6824"/> is an extension for TCP to support multi-homing. It is
designed to be as transparent as possible to middle-boxes. It does so by
establishing regular TCP flows between a pair of source/destination endpoints,
and multiplexing the application’s stream over these flows.</t>

<section anchor="protocol-description-1" title="Protocol Description">

<t>MPTCP uses TCP options for its control plane. They are used to signal multipath
capabilities, as well as to negotiate data sequence numbers, and advertise other
available IP addresses and establish new sessions between pairs of endpoints.</t>

</section>
<section anchor="interface-description-1" title="Interface Description">

<t>By default, MPTCP exposes the same interface as TCP to the application.
<xref target="RFC6897"/> however describes a richer API for MPTCP-aware applications.</t>

<t>This Basic API describes how an application can
- enable or disable MPTCP;
- bind a socket to one or more selected local endpoints;
- query local and remote endpoint addresses;
- get a unique connection identifier (similar to an address–port pair for TCP).</t>

<t>The document also recommend the use of extensions defined for SCTP <xref target="RFC6458"/>
(see next section) to deal with multihoming.</t>

<t>[AUTHOR’S NOTE: research work, and some implementation, also suggest that the
scheduling algorithm, as well as the path manager, are configurable options that
should be exposed to higher layer. Should this be discussed here?]</t>

</section>
<section anchor="transport-protocol-components-1" title="Transport Protocol Components">

<t>[AUTHOR’S NOTE: shouldn’t it be “service feature”?]</t>

<t>As an extension to TCP, MPTCP provides mostly the same components. By
establishing multiple sessions between available endpoints, it can additionally
provide soft failover solutions should one of the paths become unusable. In
addition, by multiplexing one byte stream over separate paths, it can achieve a
higher throughput than TCP in certain situations (note however that coupled
congestion control <xref target="RFC6356"/> might limit this benefit to maintain fairness to
other flows at the bottleneck). When aggregating capacity over multiple paths,
and depending on the way packets are scheduled on each TCP subflow, an
additional delay and higher jitter might be observed observed before in-order
delivery of data to the applications.</t>

<t>The transport protocol components provided by MPTCP in addition to TCP therefore are:</t>

<t><list style="symbols">
  <t>congestion control with load balancing over mutiple connections</t>
  <t>endpoint multiplexing of a single byte stream (higher throughput)</t>
  <t>resilience to network failure and/or handoverss</t>
</list></t>

<t>[AUTHOR’S NOTE: it is unclear whether MPTCP has to provide data bundling.]
[AUTHOR’S NOTE: AF muliplexing? sub-flows can be started over IPv4 or IPv6 for
the same session]</t>

</section>
</section>
<section anchor="stream-control-transmission-protocol-sctp" title="Stream Control Transmission Protocol (SCTP)">

<t>SCTP is a message oriented standards track transport protocol and the base
protocol is specified in <xref target="RFC4960"/>.
It supports multi-homing to handle path failures.
An SCTP association has multiple unidirectional streams in each direction and
provides in-sequence delivery of user messages only within each stream. This
allows to minimize head of line blocking.
SCTP is extensible and the currently defined extensions include mechanisms
for dynamic re-configurations of streams <xref target="RFC6525"/> and
IP-addresses <xref target="RFC5061"/>.
Furthermore, the extension specified in <xref target="RFC3758"/> introduces the concept of
partial reliability for user messages.</t>

<t>SCTP was originally developed for transporting telephony signalling messages
and is deployed in telephony signalling networks, especially in mobile telephony
networks.
Additionally, it is used in the WebRTC framework for data channels and is therefore deployed in all WEB-browsers supporting WebRTC.</t>

<section anchor="protocol-description-2" title="Protocol Description">

<t>SCTP is a connection oriented protocol using a four way handshake to establish
an SCTP association and a three way message exchange to gracefully shut it down.
It uses the same port number concept as DCCP, TCP, UDP, and UDP-Lite do and
only supports unicast.</t>

<t>SCTP uses the 32-bit CRC32c for protecting SCTP packets against bit errors.
This is stronger than the 16-bit checksums used by TCP or UDP.
However, a partial checksum coverage as provided by DCCP or UDP-Lite is not
supported.</t>

<t>SCTP has been designed with extensibility in mind. Each SCTP packet starts with
a single common header containing the port numbers, a verification tag and
the CRC32c checksum.
This common header is followed by a sequence of chunks.
Each chunk consists of a type field, flags, a length field and a value.
<xref target="RFC4960"/> defines how a receiver processes chunks with an unknown chunk type.
The support of extensions can be negotiated during the SCTP handshake.</t>

<t>SCTP provides a message-oriented service. Multiple small user messages can
be bundled into a single SCTP packet to improve the efficiency.
For example, this bundling may be done by delaying user messages at the sender
side similar to the Nagle algorithm used by TCP.
User messages which would result in IP packets larger than the MTU will be
fragmented at the sender side and reassembled at the receiver side.
There is no protocol limit on the user message size.
ICMP-based path MTU discovery as specified for IPv4 in <xref target="RFC1191"/> and for IPv6
in <xref target="RFC1981"/> as well as packetization layer path MTU discovery as specified in
<xref target="RFC4821"/> with probe packets using the padding chunks defined the <xref target="RFC4820"/>
are supported.</t>

<t><xref target="RFC4960"/> specifies a TCP friendly congestion control to protect the network
against overload. SCTP also uses a sliding window flow control to protect
receivers against overflow.</t>

<t>Each SCTP association has between 1 and 65536 uni-directional streams in
each direction. The number of streams can be different in each direction.
Every user-message is sent on a particular stream.
User messages can be sent un-ordered or ordered upon request by the upper layer.
Un-ordered messages can be delivered as soon as they are completely received.
Only all ordered messages sent on the same stream are delivered at the receiver
in the same order as sent by the sender. For user messages not requiring
fragmentation, this minimises head of line blocking.
The base protocol defined in <xref target="RFC4960"/> doesn’t allow interleaving of
user-messages, which results in sending a large message on one stream can block
the sending of user messages on other streams.
<xref target="I-D.ietf-tsvwg-sctp-ndata"/> overcomes this limitation.
Furthermore, <xref target="I-D.ietf-tsvwg-sctp-ndata"/> specifies multiple algorithms for
the sender side selection of which streams to send data from supporting a
variety of scheduling algorithms including priority based ones.
The stream re-configuration extension defined in <xref target="RFC6525"/> allows to reset
streams during the lifetime of an association and to increase the number of
streams, if the number of streams negotiated in the SCTP handshake is not
sufficient.</t>

<t>According to <xref target="RFC4960"/>, each user message sent is either delivered to
the receiver or, in case of excessive retransmissions, the association is
terminated in a non-graceful way, similar to the TCP behaviour.
In addition to this reliable transfer, the partial reliability extension
defined in <xref target="RFC3758"/> allows the sender to abandon user messages.
The application can specify the policy for abandoning user messages.
Examples for these policies include:</t>

<t><list style="symbols">
  <t>Limiting the time a user message is dealt with by the sender.</t>
  <t>Limiting the number of retransmissions for each fragment of a user message.
If the number of retransmissions is limited to 0, one gets a service similar
to UDP.</t>
  <t>Abandoning messages of lower priority in case of a send buffer shortage.</t>
</list></t>

<t>SCTP supports multi-homing. Each SCTP end-point uses a list of IP-addresses
and a single port number. These addresses can be any mixture of IPv4 and IPv6
addresses.
These addresses are negotiated during the handshake and the address
re-configuration extension specified in <xref target="RFC5061"/> in combination with
<xref target="RFC4895"/> can be used to change these addresses in an authenticated way
during the livetime of an SCTP association.
This allows for transport layer mobility.
Multiple addresses are used for improved resilience.
If a remote address becomes unreachable, the traffic is switched over to a
reachable one, if one exists.
Each SCTP end-point supervises continuously the reachability of all peer
addresses using a heartbeat mechanism.</t>

<t>For securing user messages, the use of TLS over SCTP has been specified in
<xref target="RFC3436"/>. However, this solution does not support all services provided
by SCTP (for example un-ordered delivery or partial reliability), and therefore
the use of DTLS over SCTP has been specified in <xref target="RFC6083"/> to overcome these
limitations. When using DTLS over SCTP, the application can use almost all
services provided by SCTP.</t>

<t><xref target="I-D.ietf-tsvwg-natsupp"/> defines a methods for end-hosts and
middleboxes to provide for NAT support for SCTP over IPv4.
For legacy NAT traversal, <xref target="RFC6951"/> defines the UDP encapsulation of
SCTP-packets. Alternatively, SCTP packets can be encapsulated in DTLS packets
as specified in <xref target="I-D.ietf-tsvwg-sctp-dtls-encaps"/>. The latter encapsulation
is used with in the WebRTC context.</t>

<t>Having a well defined API is also a feature provided by SCTP as described in
the next subsection.</t>

</section>
<section anchor="interface-description-2" title="Interface Description">

<t><xref target="RFC4960"/> defines an abstract API for the base protocol.
An extension to the BSD Sockets API is defined in <xref target="RFC6458"/> and covers:</t>

<t><list style="symbols">
  <t>the base protocol defined in <xref target="RFC4960"/>.</t>
  <t>the SCTP Partial Reliability extension defined in <xref target="RFC3758"/>.</t>
  <t>the SCTP Authentication extension defined in <xref target="RFC4895"/>.</t>
  <t>the SCTP Dynamic Address Reconfiguration extension defined in <xref target="RFC5061"/>.</t>
</list></t>

<t>For the following SCTP protocol extensions the BSD Sockets API extension is
defined in the document specifying the protocol extensions:</t>

<t><list style="symbols">
  <t>the SCTP SACK-IMMEDIATELY extension defined in <xref target="RFC7053"/>.</t>
  <t>the SCTP Stream Reconfiguration extension defined in <xref target="RFC6525"/>.</t>
  <t>the UDP Encapsulation of SCTP packets extension defined in <xref target="RFC6951"/>.</t>
  <t>the additional PR-SCTP policies defined in <xref target="I-D.ietf-tsvwg-sctp-prpolicies"/>.</t>
</list></t>

<t>Future documents describing SCTP protocol extensions are expected to describe
the corresponding BSD Sockets API extension in a <spanx style="verb">Socket API Considerations</spanx> section.</t>

<t>The SCTP socket API supports two kinds of sockets:</t>

<t><list style="symbols">
  <t>one-to-one style sockets (by using the socket type <spanx style="verb">SOCK_STREAM</spanx>).</t>
  <t>one-to-many style socket (by using the socket type <spanx style="verb">SOCK_SEQPACKET</spanx>).</t>
</list></t>

<t>One-to-one style sockets are similar to TCP sockets, there is a 1:1 relationship
between the sockets and the SCTP associations (except for listening sockets).
One-to-many style SCTP sockets are similar to unconnected UDP sockets as there
is a 1:n relationship between the sockets and the SCTP associations.</t>

<t>The SCTP stack can provide information to the applications about state
changes of the individual paths and the association whenever they occur.
These events are delivered similar to user messages but are specifically
marked as notifications.</t>

<t>A couple of new functions have been introduced to support the use of
multiple local and remote addresses.
Additional SCTP-specific send and receive calls have been defined to allow
dealing with the SCTP specific information without using ancillary data
in the form of additional cmsgs, which are also defined.
These functions provide support for detecting partial delivery of
user messages and notifications.</t>

<t>The SCTP socket API allows a fine-grained control of the protocol behaviour
through an extensive set of socket options.</t>

<t>The SCTP kernel implementations of FreeBSD, Linux and Solaris follow mostly
the specified extension to the BSD Sockets API for the base protocol and the
corresponding supported protocol extensions.</t>

</section>
<section anchor="transport-protocol-components-2" title="Transport Protocol Components">

<t>The transport protocol components provided by SCTP are:</t>

<t><list style="symbols">
  <t>unicast</t>
  <t>connection setup with feature negotiation and application-to-port mapping</t>
  <t>port multiplexing</t>
  <t>reliable or partially reliable delivery</t>
  <t>ordered and unordered delivery within a stream</t>
  <t>support for multiple concurrent streams</t>
  <t>support for stream scheduling prioritization</t>
  <t>flow control</t>
  <t>message-oriented delivery</t>
  <t>congestion control</t>
  <t>user message bundling</t>
  <t>user message fragmentation and reassembly</t>
  <t>strong error detection (CRC32C)</t>
  <t>transport layer multihoming for resilience</t>
  <t>transport layer mobility</t>
</list></t>

<t>[EDITOR’S NOTE: update this list.]</t>

</section>
</section>
<section anchor="user-datagram-protocol-udp" title="User Datagram Protocol (UDP)">

<t>The User Datagram Protocol (UDP) <xref target="RFC0768"/> <xref target="RFC2460"/> is an IETF
 standards track transport protocol.  It provides a uni-directional,
 datagram protocol which preserves message boundaries.  It provides
 none of the following transport features: error correction,
 congestion control, or flow control.  It can be used to send
 broadcast datagrams (IPv4) or multicast datagrams (IPv4 and IPv6), in
 addition to unicast (and anycast) datagrams.  IETF guidance on the
 use of UDP is provided in<xref target="RFC5405"/>.  UDP is widely implemented and
 widely used by common applications, especially DNS.</t>

<section anchor="protocol-description-3" title="Protocol Description">

<t>UDP is a connection-less protocol which maintains message boundaries,
with no connection setup or feature negotiation.  The protocol uses
independent messages, ordinarily called datagrams.  The lack of error
control and flow control implies messages may be damaged, re-ordered,
lost, or duplicated in transit.  A receiving application unable to
run sufficiently fast or frequently may miss messages.  The lack of
congestion handling implies UDP traffic may cause the loss of
messages from other protocols (e.g., TCP) when sharing the same
network paths.  UDP traffic can also cause the loss of other UDP
traffic in the same or other flows for the same reasons.</t>

<t>Messages with bit errors are ordinarily detected by an invalid end-
to-end checksum and are discarded before being delivered to an
application.  There are some exceptions to this general rule,
however.  UDP-Lite (see <xref target="RFC3828"/>, and below) provides the ability for
portions of the message contents to be exempt from checksum coverage.
It is also possible to create UDP datagrams with no checksum, and
while this is generally discouraged <xref target="RFC1122"/> <xref target="RFC5405"/>, certain
special cases permit its use <xref target="RFC6935"/>.  The checksum support
considerations for omitting the checksum are defined in <xref target="RFC6936"/>.
Note that due to the relatively weak form of checksum used by UDP,
applications that require end to end integrity of data are
recommended to include a stronger integrity check of their payload
data.</t>

<t>On transmission, UDP encapsulates each datagram into an IP packet,
which may in turn be fragmented by IP.  Applications concerned with
fragmentation or that have other requirements such as receiver flow
control, congestion control, PathMTU discovery/PLPMTUD, support for
ECN, etc need to be provided by protocols other than UDP <xref target="RFC5405"/>.</t>

</section>
<section anchor="interface-description-3" title="Interface Description">

<t><xref target="RFC0768"/> describes basic requirements for an API for UDP.
Guidance on use of common APIs is provided in <xref target="RFC5405"/>.</t>

<t>A UDP endpoint consists of a tuple of (IP address, port number).
Demultiplexing using multiple abstract endpoints (sockets) on the
same IP address are supported.  The same socket may be used by a
single server to interact with multiple clients (note: this behavior
differs from TCP, which uses a pair of tuples to identify a
connection).  Multiple server instances (processes) binding the same
socket can cooperate to service multiple clients– the socket
implementation arranges to not duplicate the same received unicast
message to multiple server processes.</t>

<t>Many operating systems also allow a UDP socket to be “connected”,
i.e., to bind a UDP socket to a specific (remote) UDP endpoint.
Unlike TCP’s connect primitive, for UDP, this is only a local
operation that serves to simplify the local send/receive functions
and to filter the traffic for the specified addresses and ports
<xref target="RFC5405"/>.</t>

</section>
<section anchor="transport-protocol-components-3" title="Transport Protocol Components">

<t>The transport protocol components provided by UDP are:</t>

<t><list style="symbols">
  <t>unidirectional</t>
  <t>port multiplexing</t>
  <t>2-tuple endpoints</t>
  <t>IPv4 broadcast, multicast and anycast</t>
  <t>IPv6 multicast and anycast</t>
  <t>IPv6 jumbograms</t>
  <t>message-oriented delivery</t>
  <t>error detection (checksum)</t>
  <t>checksum optional</t>
</list></t>

</section>
</section>
<section anchor="lightweight-user-datagram-protocol-udp-lite" title="Lightweight User Datagram Protocol (UDP-Lite)">

<t>The Lightweight User Datagram Protocol (UDP-Lite) <xref target="RFC3828"/> is an IETF
standards track transport protocol.
UDP-Lite provides a bidirectional set of logical unicast or
multicast message streams over
a datagram protocol. IETF guidance on the use of UDP-Lite is provided in
<xref target="RFC5405"/>.</t>

<section anchor="protocol-description-4" title="Protocol Description">

<t>UDP-Lite is a connection-less datagram protocol,
with no connection setup or feature negotiation.
The protocol use messages,
rather than a byte-stream.  Each stream of messages is independently
managed, therefore retransmission does not hold back data sent using
other logical streams.</t>

<t>It provides multiplexing to multiple sockets on each host using port
numbers.
An active UDP-Lite session is identified by its four-tuple of local and
remote IP
addresses and local port and remote port numbers.</t>

<t>UDP-Lite fragments packets into IP packets, constrained by the maximum
size of IP packet.</t>

<t>UDP-Lite changes the semantics of the UDP “payload length” field to
that of a “checksum coverage length” field.  Otherwise, UDP-Lite is
semantically identical to UDP.  Applications using UDP-Lite therefore
can not make
assumptions regarding the correctness of the data received in the
insensitive part of the UDP-Lite payload.</t>

<t>As for UDP, mechanisms for receiver flow control, congestion control,
PMTU or PLPMTU
discovery, support for ECN, etc need to be provided by
upper layer protocols <xref target="RFC5405"/>.</t>

<t>Examples of use include a class of applications that
can derive benefit from having
partially-damaged payloads delivered, rather than discarded. One
use is to support error
tolerate payload corruption when used over paths that include error-prone links,
another
application is when header integrity checks are required, but
payload integrity is provided by some other mechanism (e.g. <xref target="RFC6936"/>.</t>

<t>A UDP-Lite service may support IPv4 broadcast, multicast, anycast and
unicast.</t>

</section>
<section anchor="interface-description-4" title="Interface Description">

<t>There is no current API specified in the RFC Series, but guidance on
use of common APIs is provided in <xref target="RFC5405"/>.</t>

<t>The interface of UDP-Lite differs
from that of UDP by the addition of a single (socket) option that
communicates a checksum coverage length value: at the sender, this
specifies the intended checksum coverage, with the remaining
unprotected part of the payload called the “error-insensitive part”.
The checksum coverage may also be made visible to the application
via the UDP-Lite MIB module <xref target="RFC5097"/>.</t>

</section>
<section anchor="transport-protocol-components-4" title="Transport Protocol Components">

<t>The transport protocol components provided by UDP-Lite are:</t>

<t><list style="symbols">
  <t>unicast</t>
  <t>IPv4 broadcast, multicast and anycast</t>
  <t>port multiplexing</t>
  <t>non-reliable, non-ordered delivery</t>
  <t>message-oriented delivery</t>
  <t>partial integrity protection</t>
</list></t>

</section>
</section>
<section anchor="datagram-congestion-control-protocol-dccp" title="Datagram Congestion Control Protocol (DCCP)">

<t>Datagram Congestion Control Protocol (DCCP) <xref target="RFC4340"/> is an
IETF standards track
bidirectional transport protocol that provides unicast connections of
congestion-controlled unreliable messages.</t>

<t>[EDITOR’S NOTE: Gorry Fairhurst signed up as a contributor for this
section.]</t>

<t>The DCCP Problem Statement describes the goals that
DCCP sought to address <xref target="RFC4336"/>. It is suitable for
applications that transfer fairly large amounts of data and that can
benefit from control over the trade off between timeliness and
reliability <xref target="RFC4336"/>.</t>

<t>It offers  low overhead, and many characteristics
common to UDP, but can avoid “Re-inventing the wheel”
each time a new multimedia application emerges.
Specifically it includes core functions (feature
negotiation, path state management, RTT calculation,
PMTUD, etc): This allows applications to use a
compatible method defining how they send packets
and where suitable to choose common algorithms to
manage their functions.
Examples of suitable applications include interactive applications,
streaming media or on-line games <xref target="RFC4336"/>.</t>

<section anchor="protocol-description-5" title="Protocol Description">

<t>DCCP is a connection-oriented datagram protocol, providing a three way
handshake to allow a client and server to set up a connection,
and mechanisms for orderly completion and immediate teardown of
a connection. The protocol is defined by a family of RFCs.</t>

<t>It provides multiplexing to multiple sockets on each host using
port numbers. An active DCCP session is identified by its four-tuple
of local and remote IP addresses and local port and remote port numbers.
At connection setup, DCCP also exchanges the the service code <xref target="RFC5595"/>
mechanism to allow transport instantiations to indicate
the service treatment that is expected from the network.</t>

<t>The protocol segments data into messages, typically sized to
fit in IP packets, but which may be fragmented providing they
are less than the  A DCCP interface MAY allow applications to
request fragmentation for packets larger than PMTU, but not
larger than the maximum packet size allowed by the current
congestion control mechanism (CCMPS) <xref target="RFC4340"/>.</t>

<t>Each message
is identified by a sequence number. The sequence number is used to
identify segments
in acknowledgments, to detect unacknowledged segments, to measure RTT,
etc.
The protocol may support ordered or unordered delivery of data, and does
not
itself provide retransmission. There is a Data Checksum option,
which contains a strong CRC, lets endpoints
detect application data corruption. It also supports
reduced checksum coverage, a partial integrity mechanisms similar to UDP-lIte.</t>

<t>Receiver flow control is supported: limiting the amount of
unacknowledged data
that can be outstanding at a given time.</t>

<t>A DCCP protocol instance can be extended <xref target="RFC4340"/> and tuned.
Some features are sender-side only, requiring no negotiation with the
receiver;
some are receiver-side only, some are explicitly negotiated during
connection setup.</t>

<t>DCCP supports negotiation of the congestion control profile,
to provide Plug and Play congestion control mechanisms.
examples of specified profiles include
<xref target="RFC4341"/> <xref target="RFC4342"/> <xref target="RFC5662"/>.
All IETF-defined methods provide Congestion Control.</t>

<t>DCCP use a Connect packet to start a session, and permits
half-connections that allow each client to choose
features it wishes to support. Simultaneous open
<xref target="RFC5596"/>, as in TCP, can enable interoperability in
the presence of middleboxes. The Connect packet includes
a Service Code field <xref target="RFC5595"/> designed to allow middle
boxes and endpoints to identify the characteristics
required by a session. A lightweight UDP-based encapsulation (DCCP-UDP)
has been defined <xref target="RFC6773"/> that permits DCCP to be
used over paths where it is not natively supported.
Support in NAPT/NATs is defined in <xref target="RFC4340"/> and <xref target="RFC5595"/>.</t>

<t>Upper layer protocols specified on top of DCCP
include: DTLS <xref target="RFC5595"/>, RTP <xref target="RFC5672"/>,
ICE/SDP <xref target="RFC6773"/>.</t>

<t>A DCCP service is unicast.</t>

<t>A common packet format has allowed tools to evolve that can
read and interpret DCCP packets (e.g. Wireshark).</t>

</section>
<section anchor="interface-description-5" title="Interface Description">

<t>API characteristics include:
- Datagram transmission.
- Notification of the current maximum packet size.
- Send and reception of zero-length payloads.
- Set the Slow Receiver flow control at a receiver.
- Detect a Slow receiver at the sender.</t>

<t>There is no current API specified in the RFC Series.</t>

</section>
<section anchor="transport-protocol-components-5" title="Transport Protocol Components">

<t>The transport protocol components provided by DCCP are:</t>

<t><list style="symbols">
  <t>unicast</t>
  <t>connection setup with feature negotiation and application-to-port mapping</t>
  <t>Service Codes</t>
  <t>port multiplexing</t>
  <t>non-reliable, ordered delivery</t>
  <t>flow control (slow receiver function)</t>
  <t>drop notification</t>
  <t>timestamps</t>
  <t>message-oriented delivery</t>
  <t>partial integrity protection</t>
</list></t>

</section>
</section>
<section anchor="realtime-transport-protocol-rtp" title="Realtime Transport Protocol (RTP)">

<t>RTP provides an end-to-end network transport service, suitable for
applications transmitting real-time data, such as audio, video or
data, over multicast or unicast network services, including TCP, UDP,
UDP-Lite, DCCP.</t>

<t>[EDITOR’S NOTE: Varun Singh signed up as contributor for this section. Given the complexity of RTP, suggest to have an abbreviated section here contrasting RTP with other transports, and focusing on those features that are RTP-unique.]</t>

</section>
<section anchor="nack-oriented-reliable-multicast-norm" title="NACK-Oriented Reliable Multicast (NORM)">

<t>NORM is an IETF standards track protocol specified in <xref target="RFC5740"/>. The protocol was designed to support reliable bulk data dissemination to receiver groups using IP Multicast but also provides for point-to-point unicast operation. Its support for bulk data dissemination includes discrete file or computer memory-based “objects” as well as byte- and message-streaming. NORM is designed to incorporate packet erasure coding as an inherent part of its selective ARQ in response to receiver negative acknowledgements. The packet erasure coding can also be proactively applied for forward protection from packet loss. NORM transmissions are governed by TCP-friendly congestion control. NORM’s reliability, congestion control, and flow control mechanism are distinct components and can be separately controlled to meet different application needs.</t>

<section anchor="protocol-description-6" title="Protocol Description">

<t>[EDITOR’S NOTE: needs to be more clear about the application of FEC and packet erasure coding; expand ARQ.]</t>

<t>The NORM protocol is encapsulated in UDP datagrams and thus provides multiplexing for multiple sockets on hosts using port numbers. For purposes of loosely coordinated IP Multicast, NORM is not strictly connection-oriented although per-sender state is maintained by receivers for protocol operation. <xref target="RFC5740"/> does not specify a handshake protocol for connection establishment and separate session initiation can be used to coordinate port numbers. However, in-band “client-server” style connection establishment can be accomplished with the NORM congestion control signaling messages using port binding techniques like those for TCP client-server connections.</t>

<t>NORM supports bulk “objects” such as file or in-memory content but also can treat a stream of data as a logical bulk object for purposes of packet erasure coding. In the case of stream transport, NORM can support either byte streams or message streams where application-defined message boundary information is carried in the NORM protocol messages. This allows the receiver(s) to join/re-join and recover message boundaries mid-stream as needed. Application content is carried and identified by the NORM protocol with encoding symbol identifiers depending upon the Forward Error Correction (FEC) Scheme <xref target="RFC3452"/> configured. NORM uses NACK-based selective ARQ to reliably deliver the application content to the receiver(s). NORM proactively measures round-trip timing information to scale ARQ timers appropriately and to support congestion control. For multicast operation, timer-based feedback suppression is uses to achieve group size scaling with low feedback traffic levels. The feedback suppression is not applied for unicast operation.</t>

<t>NORM uses rate-based congestion control based upon the TCP-Friendly Rate Control (TFRC) <xref target="RFC4324"/> principles that are also used in DCCP <xref target="RFC4340"/>. NORM uses control messages to measure RTT and collect congestion event (e..g, loss event, ECN event, etc) information from the receiver(s) to support dynamic rate control adjustment. The TCP-Friendly Multicast Congestion Control (TFMCC) <xref target="RFC4654"/> used provides some extra features to support multicast but is functionally equivalent to TFRC in the unicast case.</t>

<t>NORM’s reliability mechanism is decoupled from congestion control. This allows alternative arrangements of transport services to be invoked. For example, fixed-rate reliable delivery can be supported or unreliable (but optionally “better than best effort” via packet erasure coding) delivery with rate-control per TFRC can be achieved. Additionally, alternative congestion control techniques may be applied. For example, TFRC rate control with congestion event detection based on ECN for links with high packet loss (e.g., wireless) has been implemented and demonstrated with NORM.</t>

<t>While NORM is NACK-based for reliability transfer, it also supports a positive acknowledgment (ACK) mechanism that can be used for receiver flow control. Again, since this mechanism is decoupled from the reliability and congestion control, applications that have different needs in this aspect can use the protocol differently. One example is the use of NORM for quasi-reliable delivery where timely delivery of newer content may be favored over completely reliable delivery of older content within buffering and RTT constraints.</t>

</section>
<section anchor="interface-description-6" title="Interface Description">

<t>The NORM specification does not describe a specific application programming interface (API) to control protocol operation. A freely-available, open source reference implementation of NORM is available at https://www.nrl.navy.mil/itd/ncs/products/norm, and a documented API is provided for this implementation. While a sockets-like API is not currently documented, the existing API supports the necessary functions for that to be implemented.</t>

</section>
<section anchor="transport-protocol-components-6" title="Transport Protocol Components">

<t>The transport protocol components provided by NORM are:</t>

<t><list style="symbols">
  <t>unicast</t>
  <t>multicast</t>
  <t>port multiplexing (UDP ports)</t>
  <t>reliable delivery</t>
  <t>unordered delivery of in-memory data or file bulk content objects</t>
  <t>error detection (UDP checksum)</t>
  <t>segmentation</t>
  <t>stream-oriented delivery in a single stream</t>
  <t>object-oriented delivery of discrete data or file items</t>
  <t>data bundling (Nagle’s algorithm)</t>
  <t>flow control (timer-based and/or ack-based)</t>
  <t>congestion control</t>
  <t>packet erasure coding (both proactively and as part of ARQ)</t>
</list></t>

</section>
</section>
<section anchor="transport-layer-security-tls-and-datagram-tls-dtls-as-a-pseudotransport" title="Transport Layer Security (TLS) and Datagram TLS (DTLS) as a pseudotransport">

<t>Transport Layer Security (TLS) and Datagram TLS (DTLS) are IETF protocols that provide
several security-related features to applications. TLS is designed to run on top
of a reliable streaming transport protocol (usually TCP), while DTLS
is designed to run on top of a best-effort datagram protocol (usually UDP).
At the time of writing, the
current version of TLS is 1.2; it is defined in <xref target="RFC5246"/>. DTLS provides
nearly identical functionality to applications; it is defined in <xref target="RFC6347"/>
and its current version is also 1.2.  The TLS protocol evolved from
the Secure Sockets Layer (SSL) protocols developed in the mid 90s to support
protection of HTTP traffic.</t>

<t>While older versions of TLS and DTLS are still in use, they provide weaker
security guarantees. <xref target="RFC7457"/> outlines important attacks on TLS and DTLS.
<xref target="RFC7525"/> is a Best Current Practices (BCP) document that describes secure
configurations for TLS and DTLS to counter these attacks. The recommendations
are applicable for the vast majority of use cases.</t>

<t>[NOTE: The Logjam authors (weakdh.org) give (inconclusive) evidence that one of
the recommendations of <xref target="RFC7525"/>, namely the use of DHE-1024 as a fallback, may
not be sufficient in all cases to counter an attacker with the resources of a
nation-state. It is unclear at this time if the RFC is going to be updated as a
result, or whether there will be an RFC7525bis.]</t>

<section anchor="protocol-description-7" title="Protocol Description">

<t>Both TLS and DTLS provide the same security features and can thus be discussed
together. The features they provide are:</t>

<t><list style="symbols">
  <t>Confidentiality</t>
  <t>Data integrity</t>
  <t>Peer authentication (optional)</t>
  <t>Perfect forward secrecy (optional)</t>
</list></t>

<t>The authentication of the peer entity can be omitted; a common web use
case is where the server is authenticated and the client is not.
TLS also provides a completely anonymous operation mode in which neither
peer’s identity is authenticated.
It is important to note that TLS itself does not specify how a peering entity’s identity
should be interpreted.  For example, in the common use case of
authentication by means of an X.509 certificate, it is the application’s
decision whether the certificate of the peering entity is acceptable for authorization decisions.
Perfect forward secrecy, if enabled and supported by the selected algorithms,
ensures that traffic encrypted and captured during a session at time t0 cannot be 
later decrypted at time t1 (t1 &gt; t0), even if the long-term secrets of the
communicating peers are later compromised.</t>

<t>As DTLS is generally used over an unreliable datagram transport such as TCP, applications
will need to tolerate loss, re-ordered, or duplicated datagrams.
Like TLS, DTLS conveys application data in a sequence of independent records.
However, because records are mapped to unreliable datagrams, there are several
features unique to DTLS that are not applicable to TLS:</t>

<t><list style="symbols">
  <t>Record replay detection (optional)</t>
  <t>Record size negotiation (estimates of PMTU and record size expansion factor)</t>
  <t>Coveyance of IP don’t fragment (DF) bit settings by application</t>
  <t>An anti-DoS stateless cookie mechanism (optional)</t>
</list></t>

<t>Generally, DTLS follows the TLS design as closely as possible.
To operate over datagrams, DTLS includes a sequence number and limited forms
of retransmission and fragmentation for its internal operations.
The sequence number may be used for detecting replayed information, according
to the windowing procedure described in Section 4.1.2.6 of <xref target="RFC6347"/>.
Note also that DTLS bans the use of stream ciphers, which are essentially incompatible
when operating on independent encrypted records.</t>

</section>
<section anchor="interface-description-7" title="Interface Description">

<t>TLS is commonly invoked using an API provided by packages such as OpenSSL, wolfSSL, or GnuTLS.
Using such APIs entails the manipulation of several important abstractions, which
fall into the following categories:
long-term keys and algorithms, session state, and communications/connections.
There may also be special APIs required to deal with time and/or random numbers, both of which
are needed by a variety of encryption algorithms and protocols.</t>

<t>Considerable care is required in the use of TLS APIs in order to create a secure
application.  The programmer should have at least a basic understanding of encryption
and digital signature algorithms and their strengths, public key infrastructure (including
X.509 certificates and certificate revocation), and the sockets API.
See <xref target="RFC7525"/> and <xref target="RFC7457"/>, as mentioned above.</t>

<t>As an example, in the case of OpenSSL, 
the primary abstractions are the library itself and method (protocol),
session, context, cipher and connection.
After initializing the library and setting the method, a cipher suite
is chosen and used to configure a context object.
Session objects may then be minted according to the parameters present
in a context object and associated with individual connections.
Depending on how precisely the programmer wishes to select different
algorithmic or protocol options, various levels of details may be required.</t>

</section>
<section anchor="transport-protocol-components-7" title="Transport Protocol Components">

<t>Both TLS and DTLS employ a layered architecture. The lower layer is commonly
called the record protocol. It is responsible for fragmenting messages, applying
message authentication codes (MACs), encrypting data, and invoking transmission
from the underlying transport protocol.  DTLS augments the TLS record
protocol with sequence numbers used for ordering and replay detection.</t>

<t>Several protocols are layered on top of the
record protocol.  These include the handshake, alert, and change cipher spec
protocols.  There is also the data protocol, used to carry application traffic.
The handshake protocol is used to establish cryptographic  and compression parameters when a connection
is first set up.  In DTLS, this protocol also has a basic fragmentation and retransmission capability and
a cookie-like mechanism to resist DoS attacks.
(TLS compression is not recommended at present).
The alert protocol is used to inform the peer of various conditions, most of which
are terminal for the connection.
The change cipher spec protocol is used to synchronize changes in cryptographic
parameters for each peer.</t>

</section>
</section>
<section anchor="hypertext-transport-protocol-http-over-tcp-as-a-pseudotransport" title="Hypertext Transport Protocol (HTTP) over TCP as a pseudotransport">

<t>Hypertext Transfer Protocol (HTTP) is an application-level protocol widely used on the Internet. Version 1.1 of the protocol is specified in <xref target="RFC7230"/> <xref target="RFC7231"/> <xref target="RFC7232"/> <xref target="RFC7233"/> <xref target="RFC7234"/> <xref target="RFC7235"/>, and version 2 in <xref target="RFC7540"/>. Furthermore, HTTP is used as a substrate for other application-layer protocols. There are various reasons for this practice listed in <xref target="RFC3205"/>; these include being a well-known and well-understood protocol, reusability of existing servers and client libraries, easy use of existing security mechanisms such as HTTP digest authentication <xref target="RFC2617"/> and TLS <xref target="RFC5246"/>, the ability of HTTP to traverse firewalls which makes it work with a lot of infrastructure, and cases where a application server often needs to support HTTP anyway.</t>

<t>Depending on application’s needs, the use of HTTP as a substrate protocol may add complexity and overhead in comparison to a special-purpose protocol (e.g. HTTP headers, suitability of the HTTP security model etc.). <xref target="RFC3205"/> address this issues and provides some guidelines and concerns about the use of HTTP standard port 80 and 443, the use of HTTP URL scheme and interaction with existing firewalls, proxies and NATs.</t>

<t>Though not strictly bound to TCP, HTTP is almost exclusively run over TCP, and therefore inherits its properties when used in this way.</t>

<section anchor="protocol-description-8" title="Protocol Description">

<t>Hypertext Transfer Protocol (HTTP) is a request/response protocol. A client sends a request containing a request method, URI and protocol version followed by a MIME-like message (see <xref target="RFC7231"/> for the differences between an HTTP object and a MIME message), containing information about the client and request modifiers. The message can contain a message body carrying application data as well. The server responds with a status or error code followed by a MIME-like message containing information about the server and information about carried data and it can include a message body. It is possible to specify a data format for the message body using MIME media types <xref target="RFC2045"/>. Furthermore, the protocol has numerous additional features; features relevant to pseudotransport are described below.</t>

<t>Content negotiation, specified in <xref target="RFC7231"/>, is a mechanism provided by HTTP for selecting a representation on a requested resource. The client and server negotiate acceptable data formats, charsets, data encoding (e.g. data can be transferred compressed, gzip), etc. HTTP can accommodate exchange of messages as well as data streaming (using chunked transfer encoding <xref target="RFC7230"/>). It is also possible to request a part of a resource using range requests specified in <xref target="RFC7233"/>. The protocol provides powerful cache control signalling defined in <xref target="RFC7234"/>.</t>

<t>HTTP 1.1’s and HTTP 2.0’s persistent connections can be use to perform multiple request-response transactions during the life-time of a single HTTP connection. Moreover, HTTP 2.0 connections can multiplex many request/response pairs in parallel on a single connection. This reduces connection establishment overhead and the effect of TCP slow-start on each transaction, important for HTTP’s primary use case.</t>

<t>It is possible to combine HTTP with security mechanisms, like TLS (denoted by HTTPS), which adds protocol properties provided by such a mechanism (e.g. authentication, encryption, etc.). TLS’s Application-Layer Protocol Negotiation (ALPN) extension <xref target="RFC7301"/> can be used for HTTP version negotiation within TLS handshake which eliminates addition round-trip. Arbitrary cookie strings, included as part of the MIME headers, are often used as bearer tokens in HTTP.</t>

<t>Application layer protocols using HTTP as substrate may use existing method and data formats, or specify new methods and data formats. Furthermore some protocols may not fit a request/response paradigm and instead rely on HTTP to send messages (e.g. <xref target="RFC6546"/>). Because HTTP is working in many restricted infrastructures, it is also used to tunnel other application-layer protocols.</t>

</section>
<section anchor="interface-description-8" title="Interface Description">

<t>There are many HTTP libraries available exposing different APIs. The APIs provide a way to specify a request by providing a URI, a method, request modifiers and optionally a request body. For the response, callbacks can be registered that will be invoked when the response is received. If TLS is used, API expose a registration of callbacks in case a server requests client authentication and when certificate verification is needed.</t>

<t>World Wide Web Consortium (W3C) standardized the XMLHttpRequest API <xref target="XHR"/>, an API that can be use for sending HTTP/HTTPS requests and receiving server responses. Besides XML data format, request and response data format can also be JSON, HTML and plain text. Specifically JavaScript and XMLHttpRequest are a ubiquitous programming model for websites, and more general applications, where native code is less attractive.</t>

<t>Representational State Transfer (REST) <xref target="REST"/> is another example how applications can use HTTP as transport protocol. REST is an architecture style for building application on the Internet. It uses HTTP as a communication protocol.</t>

</section>
<section anchor="transport-protocol-components-8" title="Transport Protocol Components">

<t>The transport protocol components provided by HTTP, when used as a pseudotransport, are:</t>

<t><list style="symbols">
  <t>unicast</t>
  <t>reliable delivery</t>
  <t>ordered delivery</t>
  <t>message and stream-oriented</t>
  <t>object range request</t>
  <t>message content type negotiation</t>
  <t>congestion control</t>
</list></t>

<t>HTTPS (HTTP over TLS) additionally provides the following components:</t>

<t><list style="symbols">
  <t>authentication (of one or both ends of a connection)</t>
  <t>confidentiality</t>
  <t>integrity protection</t>
</list></t>

</section>
</section>
<section anchor="websockets" title="WebSockets">

<t><xref target="RFC6455"/></t>

<t>[EDITOR’S NOTE: Salvatore Loreto will contribute text for this section.]</t>

<section anchor="protocol-description-9" title="Protocol Description">

</section>
<section anchor="interface-description-9" title="Interface Description">

</section>
<section anchor="transport-protocol-components-9" title="Transport Protocol Components">

</section>
</section>
</section>
<section anchor="transport-service-features" title="Transport Service Features">

<t>[EDITOR’S NOTE: This section is still work-in-progress. This list is probably not complete and/or too detailed.]</t>

<t>The transport protocol components analyzed in this document which can be used as a basis for defining common transport service features, normalized and separated into categories, are as follows:</t>

<t><list style="symbols">
  <t>Control Functions
  <list style="symbols">
      <t>Addressing
      <list style="symbols">
          <t>unicast</t>
          <t>broadcast (IPv4 only)</t>
          <t>multicast</t>
          <t>anycast</t>
          <t>something on ports and NAT</t>
        </list></t>
      <t>Multihoming support
      <list style="symbols">
          <t>multihoming for resilience</t>
          <t>multihoming for mobility
          <list style="symbols">
              <t>specify handover latency?</t>
            </list></t>
          <t>multihoming for load-balancing
          <list style="symbols">
              <t>specify interleaving delay?</t>
            </list></t>
        </list></t>
      <t>Multiplexing
      <list style="symbols">
          <t>application to port mapping</t>
          <t>single vs. multiple streaming</t>
        </list></t>
    </list></t>
  <t>Delivery
  <list style="symbols">
      <t>reliability
      <list style="symbols">
          <t>reliable delivery</t>
          <t>partially reliable delivery
          <list style="symbols">
              <t>packet erasure coding</t>
            </list></t>
          <t>unreliable delivery
          <list style="symbols">
              <t>drop notification</t>
              <t>Integrity protection
              <list style="symbols">
                  <t>checksum for error detection</t>
                  <t>partial checksum protection</t>
                  <t>checksum optional</t>
                </list></t>
            </list></t>
        </list></t>
      <t>ordering
      <list style="symbols">
          <t>ordered delivery</t>
          <t>unordered delivery
          <list style="symbols">
              <t>unordered delivery of in-memory data</t>
            </list></t>
        </list></t>
      <t>type/framing
      <list style="symbols">
          <t>stream-oriented delivery</t>
          <t>message-oriented delivery</t>
          <t>object-oriented delivery of discrete data or file items
          <list style="symbols">
              <t>object content type negotiation</t>
            </list></t>
          <t>range-based partical object transmission</t>
          <t>file bulk content objects</t>
        </list></t>
    </list></t>
  <t>Transmission control
  <list style="symbols">
      <t>rate control
      <list style="symbols">
          <t>timer-based</t>
          <t>ACK-based</t>
        </list></t>
      <t>congestion control</t>
      <t>flow control</t>
      <t>segmentation</t>
      <t>data/message bundling (Nagle’s algorithm)</t>
      <t>stream scheduling prioritization</t>
    </list></t>
  <t>Security
  <list style="symbols">
      <t>authentication of one end of a connection</t>
      <t>authentication of both ends of a connection</t>
      <t>confidentiality</t>
      <t>cryptographic integrity protection</t>
    </list></t>
</list></t>

<t>The next revision of this document will define transport service features based upon this list.</t>

<t>[EDITOR’S NOTE: this section will drawn from the candidate features provided by protocol components in the
previous section – please discuss on taps@ietf.org list]</t>

<section anchor="complete-protocol-feature-matrix" title="Complete Protocol Feature Matrix">

<t>[EDITOR’S NOTE: Dave Thaler has signed up as a contributor for this section. Michael Welzl also has a beginning of a matrix which could be useful here.]</t>

<t>[EDITOR’S NOTE: The below is a strawman proposal below by Gorry Fairhurst for initial discussion]</t>

<t>The table below summarises protocol mechanisms that have been standardised. It does not make an assessment on whether specific implementations are fully compliant to these specifications.</t>

<texttable>
      <ttcol align='left'>Mechanism</ttcol>
      <ttcol align='left'>UDP</ttcol>
      <ttcol align='left'>UDP-L</ttcol>
      <ttcol align='left'>DCCP</ttcol>
      <ttcol align='left'>SCTP</ttcol>
      <ttcol align='left'>TCP</ttcol>
      <c>Unicast</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>Mcast/IPv4Bcast</c>
      <c>Yes(2)</c>
      <c>Yes</c>
      <c>No</c>
      <c>No</c>
      <c>No</c>
      <c>Port Mux</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>Mode</c>
      <c>Dgram</c>
      <c>Dgram</c>
      <c>Dgram</c>
      <c>Dgram</c>
      <c>Stream</c>
      <c>Connected</c>
      <c>No</c>
      <c>No</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>Data bundling</c>
      <c>No</c>
      <c>No</c>
      <c>No</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>Feature Nego</c>
      <c>No</c>
      <c>No</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>Options</c>
      <c>No</c>
      <c>No</c>
      <c>Support</c>
      <c>Support</c>
      <c>Support</c>
      <c>Data priority</c>
      <c>*</c>
      <c>*</c>
      <c>*</c>
      <c>Yes</c>
      <c>No</c>
      <c>Data bundling</c>
      <c>No</c>
      <c>No</c>
      <c>No</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>Reliability</c>
      <c>None</c>
      <c>None</c>
      <c>None</c>
      <c>Select</c>
      <c>Full</c>
      <c>Ordered deliv</c>
      <c>No</c>
      <c>No</c>
      <c>No</c>
      <c>Stream</c>
      <c>Yes</c>
      <c>Corruption Tol.</c>
      <c>No</c>
      <c>Support</c>
      <c>Support</c>
      <c>No</c>
      <c>No</c>
      <c>Flow Control</c>
      <c>No</c>
      <c>No</c>
      <c>Support</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>PMTU/PLPMTU</c>
      <c>(1)</c>
      <c>(1)</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>Cong Control</c>
      <c>(1)</c>
      <c>(1)</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>ECN Support</c>
      <c>(1)</c>
      <c>(1)</c>
      <c>Yes</c>
      <c>TBD</c>
      <c>Yes</c>
      <c>NAT support</c>
      <c>Limited</c>
      <c>Limited</c>
      <c>Support</c>
      <c>TBD</c>
      <c>Support</c>
      <c>Security</c>
      <c>DTLS</c>
      <c>DTLS</c>
      <c>DTLS</c>
      <c>DTLS</c>
      <c>TLS, AO</c>
      <c>UDP encaps</c>
      <c>N/A</c>
      <c>None</c>
      <c>Yes</c>
      <c>Yes</c>
      <c>None</c>
      <c>RTP support</c>
      <c>Support</c>
      <c>Support</c>
      <c>Support</c>
      <c>?</c>
      <c>Support</c>
</texttable>

<t>Note (1): this feature requires support in an upper layer protocol.</t>

<t>Note (2): this feature requires support in an upper layer protocol when used with IPv6.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This document has no considerations for IANA.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>This document surveys existing transport protocols and protocols providing transport-like services. Confidentiality, integrity, and authenticity are among the features provided by those services. This document does not specify any new components or mechanisms for providing these features. Each RFC listed in this document discusses the security considerations of the specification it contains.</t>

</section>
<section anchor="contributors" title="Contributors">

<t>[Editor’s Note: turn this into a real contributors section with addresses once we figure out how to trick the toolchain into doing so]</t>

<!--
 -
    ins: K. Fall
    name: Kevin Fall
    email: kfall@kfall.com
 -
    ins: M. Tuexen
    name: Michael Tuexen
    org: Muenster University of Applied Sciences
    street: Stegerwaldstrasse 39
    city: 48565 Steinfurt
    country: Germany
    email: tuexen@fh-muenster.de
-->

<t><list style="symbols">
  <t><xref target="multipath-tcp-mptcp"/> on MPTCP was contributed by Simone Ferlin-Oliviera (ferlin@simula.no) and Olivier Mehani (olivier.mehani@nicta.com.au)</t>
  <t><xref target="user-datagram-protocol-udp"/> on UDP was contributed by Kevin Fall (kfall@kfall.com)</t>
  <t><xref target="stream-control-transmission-protocol-sctp"/> on SCTP was contributed by Michael Tuexen (tuexen@fh-muenster.de)</t>
  <t><xref target="nack-oriented-reliable-multicast-norm"/> on NORM was contributed by Brian Adamson (brian.adamson@nrl.navy.mil)</t>
  <t><xref target="transport-layer-security-tls-and-datagram-tls-dtls-as-a-pseudotransport"/> on MPTCP was contributed by Ralph Holz (ralph.holz@nicta.com.au) and Olivier Mehani (olivier.mehani@nicta.com.au)</t>
  <t><xref target="hypertext-transport-protocol-http-over-tcp-as-a-pseudotransport"/> on HTTP was contributed by Dragana Damjanovic (ddamjanovic@mozilla.com)</t>
</list></t>

</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>Thanks to Karen Nielsen, Joe Touch, and Michael Welzl for the comments,
feedback, and discussion. This work is partially supported by the European
Commission under grant agreement FP7-ICT-318627 mPlane; support does not imply
endorsement.</t>

<t>[EDITOR’S NOTE: add H2020-NEAT ack].</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC0791;


    </references>

    <references title='Informative References'>

&RFC0768;
&RFC0793;
&RFC0896;
&RFC1122;
&RFC1191;
&RFC1981;
&RFC2018;
&RFC2045;
&RFC2460;
&RFC2617;
&RFC3168;
&RFC3205;
&RFC3390;
&RFC3436;
&RFC3452;
&RFC3758;
&RFC3828;
&RFC4324;
&RFC4336;
&RFC4340;
&RFC4341;
&RFC4342;
&RFC4614;
&RFC4654;
&RFC4820;
&RFC4821;
&RFC4895;
&RFC4960;
&RFC5061;
&RFC5097;
&RFC5246;
&RFC5348;
&RFC5405;
&RFC5595;
&RFC5596;
&RFC5662;
&RFC5672;
&RFC5740;
&RFC6773;
&RFC5925;
&RFC5681;
&RFC6083;
&RFC6093;
&RFC6525;
&RFC6546;
&RFC6298;
&RFC6347;
&RFC6356;
&RFC6455;
&RFC6458;
&RFC6691;
&RFC6824;
&RFC6897;
&RFC6935;
&RFC6936;
&RFC6951;
&RFC7053;
&RFC7230;
&RFC7231;
&RFC7232;
&RFC7233;
&RFC7234;
&RFC7235;
&RFC7301;
&RFC7323;
&RFC7457;
&RFC7525;
&RFC7540;
&I-D.ietf-aqm-ecn-benefits;
&I-D.ietf-tsvwg-sctp-dtls-encaps;
&I-D.ietf-tsvwg-sctp-prpolicies;
&I-D.ietf-tsvwg-sctp-ndata;
&I-D.ietf-tsvwg-natsupp;
<reference anchor="XHR" >
  <front>
    <title>XMLHttpRequest working draft (http://www.w3.org/TR/XMLHttpRequest/)</title>
    <author initials="A." surname="van Kesteren">
      <organization></organization>
    </author>
    <author initials="J." surname="Aubourg">
      <organization></organization>
    </author>
    <author initials="J." surname="Song">
      <organization></organization>
    </author>
    <author initials="H.R.M." surname="Steen">
      <organization></organization>
    </author>
    <date year="2000"/>
  </front>
</reference>
<reference anchor="REST" >
  <front>
    <title>Architectural Styles and the Design of Network-based Software Architectures, Ph. D. (UC Irvune), Chapter 5: Representational State Transfer</title>
    <author initials="R.T." surname="Fielding">
      <organization></organization>
    </author>
    <date year="2000"/>
  </front>
</reference>


    </references>



  </back>
</rfc>

