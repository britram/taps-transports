<?xml version="1.0" encoding="us-ascii"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.30 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC0768 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.0768.xml">
<!ENTITY RFC0792 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.0792.xml">
<!ENTITY RFC0793 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.0793.xml">
<!ENTITY RFC0896 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.0896.xml">
<!ENTITY RFC1122 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.1122.xml">
<!ENTITY RFC1191 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.1191.xml">
<!ENTITY RFC1716 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.1716.xml">
<!ENTITY RFC1981 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.1981.xml">
<!ENTITY RFC2018 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.2018.xml">
<!ENTITY RFC2045 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.2045.xml">
<!ENTITY RFC2460 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.2460.xml">
<!ENTITY RFC2461 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.2461.xml">
<!ENTITY RFC2617 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.2617.xml">
<!ENTITY RFC2710 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.2710.xml">
<!ENTITY RFC2736 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.2736.xml">
<!ENTITY RFC3168 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.3168.xml">
<!ENTITY RFC3205 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.3205.xml">
<!ENTITY RFC3260 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.3260.xml">
<!ENTITY RFC3436 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.3436.xml">
<!ENTITY RFC3450 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.3450.xml">
<!ENTITY RFC3452 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.3452.xml">
<!ENTITY RFC3550 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.3550.xml">
<!ENTITY RFC3738 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.3738.xml">
<!ENTITY RFC3758 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.3758.xml">
<!ENTITY RFC3828 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.3828.xml">
<!ENTITY RFC3926 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.3926.xml">
<!ENTITY RFC3971 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.3971.xml">
<!ENTITY RFC4324 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.4324.xml">
<!ENTITY RFC4336 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.4336.xml">
<!ENTITY RFC4340 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.4340.xml">
<!ENTITY RFC4341 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.4341.xml">
<!ENTITY RFC4342 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.4342.xml">
<!ENTITY RFC4433 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.4433.xml">
<!ENTITY RFC4654 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.4654.xml">
<!ENTITY RFC4820 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.4820.xml">
<!ENTITY RFC4821 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.4821.xml">
<!ENTITY RFC4828 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.4828.xml">
<!ENTITY RFC4895 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.4895.xml">
<!ENTITY RFC4960 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.4960.xml">
<!ENTITY RFC5061 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.5061.xml">
<!ENTITY RFC5097 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.5097.xml">
<!ENTITY RFC5246 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC5238 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.5238.xml">
<!ENTITY RFC5348 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.5348.xml">
<!ENTITY RFC5461 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.5461.xml">
<!ENTITY RFC5595 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.5595.xml">
<!ENTITY RFC5596 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.5596.xml">
<!ENTITY RFC5622 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.5622.xml">
<!ENTITY RFC5651 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.5651.xml">
<!ENTITY RFC5672 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.5672.xml">
<!ENTITY RFC5740 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.5740.xml">
<!ENTITY RFC5775 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.5775.xml">
<!ENTITY RFC5681 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.5681.xml">
<!ENTITY RFC6056 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.6056.xml">
<!ENTITY RFC6083 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.6083.xml">
<!ENTITY RFC6093 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.6093.xml">
<!ENTITY RFC6525 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.6525.xml">
<!ENTITY RFC6347 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.6347.xml">
<!ENTITY RFC6356 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.6356.xml">
<!ENTITY RFC6363 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.6363.xml">
<!ENTITY RFC6458 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.6458.xml">
<!ENTITY RFC6584 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.6584.xml">
<!ENTITY RFC6726 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.6726.xml">
<!ENTITY RFC6773 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.6773.xml">
<!ENTITY RFC6824 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.6824.xml">
<!ENTITY RFC6897 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.6897.xml">
<!ENTITY RFC6935 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.6935.xml">
<!ENTITY RFC6936 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.6936.xml">
<!ENTITY RFC6951 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.6951.xml">
<!ENTITY RFC7053 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.7053.xml">
<!ENTITY RFC7202 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.7202.xml">
<!ENTITY RFC7230 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.7230.xml">
<!ENTITY RFC7231 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.7231.xml">
<!ENTITY RFC7232 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.7232.xml">
<!ENTITY RFC7233 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.7233.xml">
<!ENTITY RFC7234 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.7234.xml">
<!ENTITY RFC7235 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.7235.xml">
<!ENTITY RFC7301 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.7301.xml">
<!ENTITY RFC7323 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.7323.xml">
<!ENTITY RFC7414 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.7414.xml">
<!ENTITY RFC7457 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.7457.xml">
<!ENTITY RFC7496 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.7496.xml">
<!ENTITY RFC7525 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.7525.xml">
<!ENTITY RFC7540 SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml/reference.RFC.7540.xml">
<!ENTITY I-D.ietf-tsvwg-rfc5405bis SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml3/reference.I-D.ietf-tsvwg-rfc5405bis.xml">
<!ENTITY I-D.ietf-tsvwg-sctp-dtls-encaps SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml3/reference.I-D.ietf-tsvwg-sctp-dtls-encaps.xml">
<!ENTITY I-D.ietf-tsvwg-sctp-ndata SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml3/reference.I-D.ietf-tsvwg-sctp-ndata.xml">
<!ENTITY I-D.ietf-tsvwg-natsupp SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml3/reference.I-D.ietf-tsvwg-natsupp.xml">
<!ENTITY I-D.ietf-tcpm-cubic SYSTEM "http://unicorn-wg.github.io/idrefs/bibxml3/reference.I-D.ietf-tcpm-cubic.xml">
]>

<?rfc toc="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-taps-transports-10" category="info">

  <front>
    <title abbrev="TAPS Transports">Services provided by IETF transport protocols and congestion control mechanisms</title>

    <author initials="G." surname="Fairhurst" fullname="Godred Fairhurst" role="editor">
      <organization>University of Aberdeen</organization>
      <address>
        <postal>
          <street>School of Engineering, Fraser Noble Building</street>
          <city>Aberdeen AB24 3UE</city>
        </postal>
        <email>gorry@erg.abdn.ac.uk</email>
      </address>
    </author>
    <author initials="B." surname="Trammell" fullname="Brian Trammell" role="editor">
      <organization>ETH Zurich</organization>
      <address>
        <postal>
          <street>Gloriastrasse 35</street>
          <city>8092 Zurich</city>
          <country>Switzerland</country>
        </postal>
        <email>ietf@trammell.ch</email>
      </address>
    </author>
    <author initials="M." surname="Kuehlewind" fullname="Mirja Kuehlewind" role="editor">
      <organization>ETH Zurich</organization>
      <address>
        <postal>
          <street>Gloriastrasse 35</street>
          <city>8092 Zurich</city>
          <country>Switzerland</country>
        </postal>
        <email>mirja.kuehlewind@tik.ee.ethz.ch</email>
      </address>
    </author>

    <date year="2016" month="March" day="04"/>

    
    
    

    <abstract>


<t>This document describes, surveys, classifies and compares the protocol
mechanisms provided by existing IETF protocols, as background for determining
a common set of transport services. It examines the Transmission Control
Protocol (TCP), Multipath TCP, the Stream Control Transmission Protocol
(SCTP), the User Datagram Protocol (UDP), UDP-Lite, the Datagram Congestion
Control Protocol (DCCP), the Internet Control Message Protocol (ICMP), the
Realtime Transport Protocol (RTP), File Delivery over Unidirectional
Transport/Asynchronous Layered Coding Reliable Multicast (FLUTE/ALC), and
NACK-Oriented Reliable Multicast (NORM), Transport Layer Security (TLS),
Datagram TLS (DTLS), and the Hypertext Transport Protocol (HTTP) when used as
a pseudotransport.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Internet applications make use of the Services provided by a 
Transport protocol, such as 
TCP (a reliable, in-order stream protocol) or UDP (an unreliable datagram
protocol). We use the term &ldquo;Transport Service&rdquo; to mean the end-to-end
service provided to an application by the transport layer. That service
can only be provided correctly if information about the intended usage is
supplied from the application. The application may determine this
information at design time, compile time, or run time, and may include
guidance on whether a feature is required, a preference by the
application, or something in between. Examples of features of Transport
Services are reliable delivery, ordered delivery, content privacy to
in-path devices, and integrity protection.</t>

<t>The IETF has defined a wide variety of transport protocols beyond TCP and
UDP, including SCTP, DCCP, MPTCP, and UDP-Lite. Transport services
may be provided directly by these transport protocols, or layered on top
of them using protocols such as WebSockets (which runs over TCP), RTP
(over TCP or UDP) or WebRTC data channels (which run over SCTP over DTLS
over UDP or TCP). Services built on top of UDP or UDP-Lite typically also
need to specify additional mechanisms, including a congestion control
mechanism (such as NewReno, TFRC or LEDBAT).  This extends the set of available
Transport Services beyond those provided to applications by TCP and UDP.</t>

<section anchor="overview-of-transport-features" title="Overview of Transport Features">

<t>Transport protocols can be differentiated by the features of the services they
provide.</t>

<t>Some of these provided features are closely related to basic control function
that a protocol needs to work over a network path, such as addressing. The
number of participants in a given association also determines its
applicability: if a connection is between endpoints (unicast), to one of
multiple endpoints (anycast), and/or simultaneously to multiple endpoints
(multicast). Unicast protocols usually support bidirectional communication,
while multicast is generally unidirectional. Another feature is whether a
transport requires a control exchange across the network at setup (e.g., TCP),
or whether it connection-less (e.g., UDP).</t>

<t>For the delivery of the packets itself, reliability and integrity protection,
ordering, and framing are basic features. However, these features are
implemented with different levels of assurance in different protocols. As an
example, a transport service may provide full reliability, providing detection
of loss and retransmission (e.g., TCP). SCTP offers a message-based service
that can provide full or partial reliability, and allows the protocol to
minimize the head of line blocking due to the support of ordered and unordered
message delivery within multiple streams. UDP-Lite and DCCP can provide
partial integrity protection to enable corruption tolerance.</t>

<t>Usually a protocol has been designed to support one specific type of
delivery/framing: data either needs to be divided into transmission units
based on network packets (datagram service), a data stream is segmented and
re-combined across multiple packets (stream service), or whole objects such as
files are handled accordingly. This decision strongly influences the interface
that is provided to the upper layer.</t>

<t>In addition, transport protocols offer a certain support for transmission
control. For example, a transport service can provide flow control to allow a
receiver to regulate the transmission rate of a sender. Further a transport
service can provide congestion control  (see <xref target="congestion-control"/>). As an
example TCP and SCTP provide  congestion control for use in the Internet,
whereas UDP leaves this function to the upper layer protocol that uses UDP.</t>

<t>Security features are often provided independent of the transport protocol,
via Transport Layer Security (TLS, see 
<xref target="transport-layer-security-tls-and-datagram-tls-dtls-as-a-pseudotransport"/>) 
or by the application layer protocol
itself. The security properties TLS provides to the application (such as
confidentiality, integrity, and authenticity) are also features of the
transport layer, even though they are often presently implemented in a
separate protocol.</t>

</section>
</section>
<section anchor="terminology" title="Terminology">

<t>The following terms are used throughout this document, and in
subsequent documents produced by TAPS that describe the composition and
decomposition of transport services.</t>

<t><list style="hanging">
  <t hangText='Transport Service Feature:'>
  a specific end-to-end feature that the transport layer provides to 
an application. Examples include confidentiality, reliable delivery, ordered
delivery, message-versus-stream orientation, etc.</t>
  <t hangText='Transport Service:'>
  a set of Transport Features, without an association to any given
framing protocol, which provides a complete service to an application.</t>
  <t hangText='Transport Protocol:'>
  an implementation that provides one or more different transport services
using a specific framing and header format on the wire.</t>
  <t hangText='Transport Service Instance:'>
  an arrangement of transport protocols with a selected set of features
and configuration parameters that implements a single transport service,
e.g., a protocol stack (RTP over UDP).</t>
  <t hangText='Application:'>
  an entity that uses the transport layer for end-to-end delivery data
across the network (this may also be an upper layer protocol or tunnel
encapsulation).</t>
</list></t>

</section>
<section anchor="existing-transport-protocols" title="Existing Transport Protocols">

<t>This section provides a list of known IETF transport protocols and transport
protocol frameworks.  It does not make an assessment about whether specific
implementations of protocols are fully compliant to current IETF
specifications.</t>

<section anchor="transport-control-protocol-tcp" title="Transport Control Protocol (TCP)">

<t>TCP is an IETF standards track transport protocol. <xref target="RFC0793"/> introduces TCP
as follows: &ldquo;The Transmission Control Protocol (TCP) is intended for use as a
highly reliable host-to-host protocol between hosts in packet-switched
computer communication networks, and in interconnected systems of such
networks.&rdquo; Since its introduction, TCP has become the default connection-
oriented, stream-based transport protocol in the Internet. It is widely
implemented by endpoints and widely used by common applications.</t>

<section anchor="protocol-description" title="Protocol Description">

<t>TCP is a connection-oriented protocol, providing a three way handshake to
allow a client and server to set up a connection and negotiate features, and
mechanisms for orderly completion and immediate teardown of a connection. TCP
is defined by a family of RFCs <xref target="RFC7414"/>.</t>

<t>TCP provides multiplexing to multiple sockets on each host using port numbers.
A similar approach is adopted by other IETF-defined transports.
An active TCP session is identified by its four-tuple of local and remote IP
addresses and local port and remote port numbers. The destination port during
connection setup is often used to indicate the requested service.</t>

<t>TCP partitions a continuous stream of bytes into segments, sized to fit in IP
packets based on a negotiated maximum segment size and further constrained by 
the effective Maximum Transmission Unit (MTU) from Path MTU Discovery (PMTUD). 
ICMP-based Path MTU discovery <xref target="RFC1191"/><xref target="RFC1981"/> as well as
Packetization Layer Path MTU Discovery (PMTUD) <xref target="RFC4821"/> have been
defined by the IETF.</t>

<t>Each byte in the stream is identified by a sequence number. The sequence
number is used to order segments on receipt, to identify segments in
acknowledgments, and to detect unacknowledged segments for retransmission.
This is the basis of the reliable, ordered delivery of data in a TCP stream. TCP
Selective Acknowledgment (SACK) <xref target="RFC2018"/> extends this mechanism by making it
possible to provide earlier identification of which segments are missing, 
allowing faster retransmission. SACK-based methods (e.g. DSACK) can also result 
in less spurious retransmission.</t>

<t>Receiver flow control is provided by a sliding window: limiting the amount of
unacknowledged data that can be outstanding at a given time. The window scale
option <xref target="RFC7323"/> allows a receiver to use windows greater than 64KB.</t>

<t>All TCP senders provide congestion control, such as described in <xref target="RFC5681"/>.
TCP uses a sequence number with a sliding receiver window for flow
control. The TCP congestion control mechanism also utilises this TCP
sequence number to manage a separate congestion window <xref target="RFC5681"/>.
The sending window at a given point in time 
is the minimum of the receiver window and the congestion window. The
congestion window is increased in the absence of congestion and, respectively,
decreased if congestion is detected. Often loss is implicitly handled as a
congestion indication which is detected in TCP (also as input for
retransmission handling) based on two mechanisms: A retransmission timer with
exponential back-up or the reception of three acknowledgment for the same
segment, so called duplicated ACKs (Fast retransmit). In addition, Explicit
Congestion Notification (ECN) <xref target="RFC3168"/> can be used in TCP, if supported by
both endpoints, that allows a network node to signal congestion without
inducing loss. Alternatively, a delay-based congestion control scheme can be
used in TCP that reacts to changes in delay as an early indication of
congestion as also further described in <xref target="congestion-control"/>.
Examples for different kind of congestion control schemes are
given in <xref target="congestion-control"/>.</t>

<t>TCP protocol instances can be extended <xref target="RFC7414"/> and tuned. Some features
are sender-side only, requiring no negotiation with the receiver; some are
receiver-side only, some are explicitly negotiated during connection setup.</t>

<t>TCP may buffer data, e.g., to optimize processing or
capacity usage. TCP can therefore provides mechanisms to control this, including
an optional &ldquo;PUSH&rdquo; function <xref target="RFC0793"/> that explicitly requests the 
transport service not to  delay data. 
By default, TCP segment partitioning uses Nagle&rsquo;s algorithm <xref target="RFC0896"/> to
buffer data at the sender into large segments, potentially incurring
sender-side buffering delay; this algorithm can be disabled by the sender to
transmit more immediately, e.g., to reduce latency for interactive sessions.</t>

<t>TCP provides an &ldquo;urgent data&rdquo; function for limited out-of-order delivery of
the data. This function is deprecated <xref target="RFC6093"/>.</t>

<t>A mandatory checksum provides a basic integrity check against misdelivery and
data corruption over the entire packet. Applications that require end to end
integrity of data are recommended to include a stronger integrity check of
their payload data. The TCP checksum does not support partial payload
protection (as in DCCP/UDP-Lite).</t>

<t>TCP supports only unicast connections.</t>

</section>
<section anchor="interface-description" title="Interface description">

<t>A User/TCP Interface is defined in <xref target="RFC0793"/> providing six user commands:
Open, Send, Receive, Close, Status. This interface does not describe
configuration of TCP options or parameters beside use of the PUSH and URGENT
flags.</t>

<t><xref target="RFC1122"/> describes extensions of the TCP/application layer interface for:</t>

<t><list style="symbols">
  <t>reporting soft errors such as reception of ICMP error messages, extensive retransmission or urgent pointer advance,</t>
  <t>providing a possibility to specify the Differentiated Services Code Point (DSCP) <xref target="RFC3260"/> (formerly, the Type-of-Service, TOS) for segments,</t>
  <t>providing a flush call to empty the TCP send queue, and</t>
  <t>multihoming support.</t>
</list></t>

<t>In API implementations derived from the BSD Sockets API, TCP sockets are
created using the <spanx style="verb">SOCK_STREAM</spanx> socket type as described in the IEEE Portable
Operating System Interface (POSIX) Base Specifications <xref target="POSIX"/>.
The features used by a protocol instance may be set and tuned via this API.
There are currently no documents in the RFC Series that describe this interface.</t>

</section>
<section anchor="transport-features" title="Transport Features">

<t>The transport features provided by TCP are:</t>

<t><list style="symbols">
  <t>connection-oriented transport with feature negotiation and application-to-port mapping (implemented using SYN segments and the TCP option field to negotiate features),</t>
  <t>unicast transport (though anycast TCP is implemented, at risk of instability due to rerouting),</t>
  <t>port multiplexing,</t>
  <t>uni- or bidirectional communication,</t>
  <t>stream-oriented delivery in a single stream,</t>
  <t>fully reliable delivery (implemented using ACKs sent from the receiver to confirm delivery),</t>
  <t>error detection (implemented using a segment checksum to verify delivery to the correct endpoint and integrity of the data and options),</t>
  <t>segmentation,</t>
  <t>data bundling (optional; uses Nagle&rsquo;s algorithm to coalesce data sent within the same RTT into full-sized segments),</t>
  <t>flow control (implemented using a window-based mechanism where the receiver advertises the window that it is willing to buffer),</t>
  <t>congestion control (usually implemented using a window-based mechanism and four algorithm for different phases of the transmission: slow start, congestion avoidance, fast retransmit, and fast recovery <xref target="RFC5681"/>).</t>
</list></t>

</section>
</section>
<section anchor="multipath-tcp-mptcp" title="Multipath TCP (MPTCP)">

<t>Multipath TCP <xref target="RFC6824"/> is an extension for TCP to support multi-homing for
resilience, mobility and load-balancing. It is
designed to be as transparent as possible to middleboxes. It does so by
establishing regular TCP flows between a pair of source/destination endpoints,
and multiplexing the application&rsquo;s stream over these flows. 
Sub-flows can be started over IPv4 or IPv6 for
the same session.</t>

<section anchor="protocol-description-1" title="Protocol Description">

<t>MPTCP uses TCP options for its control plane. They are used to signal multipath
capabilities, as well as to negotiate data sequence numbers, and advertise other
available IP addresses and establish new sessions between pairs of endpoints.</t>

<t>By multiplexing one byte stream over separate paths, MPTCP can achieve a
higher throughput than TCP in certain situations. However, if coupled
congestion control <xref target="RFC6356"/> is used, it might limit this benefit to
maintain fairness to other flows at the bottleneck. When aggregating capacity
over multiple paths, and depending on the way packets are scheduled on each
TCP subflow, additional delay and higher jitter might be observed observed
before in-order delivery of data to the applications.</t>

</section>
<section anchor="interface-description-1" title="Interface Description">

<t>By default, MPTCP exposes the same interface as TCP to the application.
<xref target="RFC6897"/> however describes a richer API for MPTCP-aware applications.</t>

<t>This Basic API describes how an application can:</t>

<t><list style="symbols">
  <t>enable or disable MPTCP.</t>
  <t>bind a socket to one or more selected local endpoints.</t>
  <t>query local and remote endpoint addresses.</t>
  <t>get a unique connection identifier (similar to an address&ndash;port pair for TCP).</t>
</list></t>

<t>The document also recommends the use of extensions defined for SCTP <xref target="RFC6458"/>
(see next section) to support multihoming for resilience and mobility.</t>

</section>
<section anchor="transport-features-1" title="Transport features">

<t>As an extension to TCP, MPTCP provides mostly the same features. By
establishing multiple sessions between available endpoints, it can additionally
provide soft failover solutions in the case that one of the paths 
become unusable.</t>

<t>The transport features provided by MPTCP in addition to TCP therefore are:</t>

<t><list style="symbols">
  <t>multihoming for load-balancing, with endpoint multiplexing of a single byte stream, using either coupled congestion control or for throughput maximization,</t>
  <t>address family multiplexing (using IPv4 and IPv6 for the same session),</t>
  <t>resilience to network failure and/or handover.</t>
</list></t>

</section>
</section>
<section anchor="user-datagram-protocol-udp" title="User Datagram Protocol (UDP)">

<t>The User Datagram Protocol (UDP) <xref target="RFC0768"/> <xref target="RFC2460"/> is an IETF standards
track transport protocol. It provides a unidirectional datagram protocol that
preserves message boundaries. It provides  no error correction, congestion
control, or flow control. It can be used to send  broadcast datagrams (IPv4)
or multicast datagrams (IPv4 and IPv6), in addition to unicast and anycast
datagrams. IETF guidance on the use of UDP is provided in 
<xref target="I-D.ietf-tsvwg-rfc5405bis"/>. UDP is widely implemented and widely used by 
common applications, including DNS.</t>

<section anchor="protocol-description-2" title="Protocol Description">

<t>UDP is a connection-less protocol that maintains message boundaries, with no
connection setup or feature negotiation. The protocol uses independent
messages, ordinarily called datagrams. It provides detection of payload errors and
misdelivery of packets to an unintended endpoint, either of which result in
discard of received datagrams, with no indication to the user of the service.</t>

<t>It is possible to create IPv4 UDP datagrams with no checksum, and while this
is generally discouraged <xref target="RFC1122"/> <xref target="I-D.ietf-tsvwg-rfc5405bis"/>, certain
special cases permit this use. These datagrams rely on the IPv4 header checksum
to protect from misdelivery to an unintended endpoint. IPv6 does not permit UDP
datagrams with no checksum, although in certain cases this rule may be relaxed
<xref target="RFC6935"/>.</t>

<t>UDP does not provide reliability and does not provide retransmission. This
implies messages may be re-ordered, lost, or duplicated in transit.
Note that due to the relatively weak form of checksum
used by UDP, applications that require end to end integrity of data are
recommended to include a stronger integrity check of their payload data.</t>

<t>Because UDP provides no flow control, a receiving application that is unable
to run sufficiently fast, or frequently, may miss messages. The lack of
congestion handling implies UDP traffic may experience loss when using an
overloaded path, and may cause the loss of messages from other protocols
(e.g., TCP) when sharing the same network path.</t>

<t>On transmission, UDP encapsulates each datagram into 
a single IP packet or several IP packet fragments. This
allows a datagram to be larger than the effective path MTU.
Fragments are reassembled before delivery to the UDP receiver,
making this transparent to the user of the transport service.
When the jumbograms are supported, larger messages may be sent without 
performing fragmentation.</t>

<t>Applications that need to provide
fragmentation or that have other requirements such as receiver flow
control, congestion control, PathMTU discovery/PLPMTUD, support for
ECN, etc. need these to be provided by protocols operating over UDP 
<xref target="I-D.ietf-tsvwg-rfc5405bis"/>.</t>

</section>
<section anchor="interface-description-2" title="Interface Description">

<t><xref target="RFC0768"/> describes basic requirements for an API for UDP.
Guidance on use of common APIs is provided in <xref target="I-D.ietf-tsvwg-rfc5405bis"/>.</t>

<t>A UDP endpoint consists of a tuple of (IP address, port number).
De-multiplexing using multiple abstract endpoints (sockets) on the
same IP address is supported. The same socket may be used by a
single server to interact with multiple clients (note: this behavior
differs from TCP, which uses a pair of tuples to identify a
connection). Multiple server instances (processes) that bind to the same
socket can cooperate to service multiple clients. The socket
implementation arranges to not duplicate the same received unicast
message to multiple server processes.</t>

<t>Many operating systems also allow a UDP socket to be &ldquo;connected&rdquo;,
i.e., to bind a UDP socket to a specific (remote) UDP endpoint.
Unlike TCP&rsquo;s connect primitive, for UDP, this is only a local
operation that serves to simplify the local send/receive functions
and to filter the traffic for the specified addresses and ports
<xref target="I-D.ietf-tsvwg-rfc5405bis"/>.</t>

</section>
<section anchor="transport-features-2" title="Transport Features">

<t>The transport features provided by UDP are:</t>

<t><list style="symbols">
  <t>unicast, multicast, anycast, or IPv4 broadcast transport,</t>
  <t>port multiplexing (where a receiving port can be configured to receive datagrams from multiple senders),</t>
  <t>message-oriented delivery,</t>
  <t>uni- or bidirectional communication where the transmissions in each direction are independent,</t>
  <t>non-reliable delivery,</t>
  <t>unordered delivery,</t>
  <t>error detection (implemented using a segment checksum to verify delivery to the correct endpoint and integrity of the data; optional for IPv4 and optional under specific conditions for IPv6 where all or none of the payload data is protected),</t>
</list></t>

</section>
</section>
<section anchor="lightweight-user-datagram-protocol-udp-lite" title="Lightweight User Datagram Protocol (UDP-Lite)">

<t>The Lightweight User Datagram Protocol (UDP-Lite) <xref target="RFC3828"/> is an IETF
standards track transport protocol. It provides a unidirectional, datagram
protocol that preserves message boundaries. IETF guidance on the use of UDP-
Lite is provided in <xref target="I-D.ietf-tsvwg-rfc5405bis"/>. A UDP-Lite service may support 
IPv4 broadcast, multicast, anycast and
unicast, and IPv6 multicast, anycast and unicast.</t>

<t>Examples of use include a class of applications that can derive benefit from
having partially-damaged payloads delivered, rather than discarded. One use is
to support error tolerate payload corruption when used over paths that include
error-prone links, another application is when header integrity checks are
required, but payload integrity is provided by some other mechanism (e.g.,
<xref target="RFC6936"/>).</t>

<section anchor="protocol-description-3" title="Protocol Description">

<t>Like UDP, UDP-Lite is a connection-less datagram protocol, with no connection
setup or feature negotiation. It changes the semantics of the UDP &ldquo;payload
length&rdquo; field to that of a &ldquo;checksum coverage length&rdquo; field, and is identified
by a different IP protocol/next-header value. The &ldquo;checksum coverage length&rdquo; field
specifies the intended checksum coverage, with the remaining
unprotected part of the payload called the &ldquo;error-insensitive part&rdquo;. 
Applications using UDP-Lite therefore cannot
make assumptions regarding the correctness of the data received in the
insensitive part of the UDP-Lite payload.</t>

<t>Otherwise, UDP-Lite is semantically identical to UDP. 
In the same way as for UDP, mechanisms for receiver flow control, congestion control, PMTU or
PLPMTU discovery, support for ECN, etc. needs to be provided by upper layer
protocols <xref target="I-D.ietf-tsvwg-rfc5405bis"/>.</t>

</section>
<section anchor="interface-description-3" title="Interface Description">

<t>There is no API currently specified in the RFC Series, but guidance on
use of common APIs is provided in <xref target="I-D.ietf-tsvwg-rfc5405bis"/>.</t>

<t>The interface of UDP-Lite differs
from that of UDP by the addition of a single (socket) option that
communicates a checksum coverage length value.
The checksum coverage may also be made visible to the application
via the UDP-Lite MIB module <xref target="RFC5097"/>.</t>

</section>
<section anchor="transport-features-3" title="Transport Features">

<t>The transport features provided by UDP-Lite are:</t>

<t><list style="symbols">
  <t>unicast, multicast, anycast, or IPv4 broadcast transport (as for UDP),</t>
  <t>port multiplexing (as for UDP),</t>
  <t>message-oriented delivery (as for UDP),</t>
  <t>Uni- or bidirectional communication where the transmissions in each direction are independent (as for UDP),</t>
  <t>non-reliable delivery (as for UDP),</t>
  <t>non-ordered delivery (as for UDP),</t>
  <t>partial or full payload error detection (where the checksum coverage field indicates the size of the payload data covered by the checksum).</t>
</list></t>

</section>
</section>
<section anchor="stream-control-transmission-protocol-sctp" title="Stream Control Transmission Protocol (SCTP)">

<t>SCTP is a message-oriented IETF standards track transport protocol. The base
protocol is specified in <xref target="RFC4960"/>. It supports multi-homing and path
failover to provide resilience to path failures. An SCTP association has
multiple streams in each direction, providing in-sequence delivery of user
messages within each stream. This allows it to minimize head of line blocking.
SCTP supports multiple stream scheduling schemes controlling stream
multiplexing, including priority and fair weighting schemes.</t>

<t>SCTP was originally developed for transporting telephony signaling messages
and is deployed in telephony signaling networks, especially in mobile
telephony networks. It can also be used for other services, for example, in the
WebRTC framework for data channels.</t>

<section anchor="protocol-description-4" title="Protocol Description">

<t>SCTP is a connection-oriented protocol using a four way handshake to establish
an SCTP association, and a three way message exchange to gracefully shut it
down. It uses the same port number concept as DCCP, TCP, UDP, and UDP-Lite.
SCTP only supports unicast.</t>

<t>SCTP uses the 32-bit CRC32c for protecting SCTP packets against bit errors and
misdelivery of packets to an unintended endpoint. This is stronger than the 16-bit
checksums used by TCP or UDP. However, partial payload checksum coverage as
provided by DCCP or UDP-Lite is not supported.</t>

<t>SCTP has been designed with extensibility in mind. A common header is followed
by a sequence of chunks. <xref target="RFC4960"/> defines how a receiver processes chunks
with an unknown chunk type. The support of extensions can be negotiated during
the SCTP handshake. Currently defined extensions include mechanisms for
dynamic re-configuration of streams <xref target="RFC6525"/> and IP addresses <xref target="RFC5061"/>.
Furthermore, the extension specified in <xref target="RFC3758"/> introduces the concept of
partial reliability for user messages.</t>

<t>SCTP provides a message-oriented service. Multiple small user messages can be
bundled into a single SCTP packet to improve efficiency. For example, this
bundling may be done by delaying user messages at the sender, similar to
Nagle&rsquo;s algorithm used by TCP. User messages which would result in IP packets
larger than the MTU will be fragmented at the sender and reassembled at the
receiver. There is no protocol limit on the user message size. 
For MTU discovery the same mechanism than for TCP can be used <xref target="RFC1981"/><xref target="RFC4821"/>,
as well as utilizing probe packets with padding chunks, as defined in <xref target="RFC4820"/>.</t>

<t><xref target="RFC4960"/> specifies TCP-friendly congestion control to protect the network
against overload. SCTP also uses sliding
window flow control to protect receivers against overflow. Similar to TCP,
SCTP also supports delaying acknowledgments. <xref target="RFC7053"/> provides a way for
the sender of user messages to request the immediate sending of the
corresponding acknowledgments.</t>

<t>Each SCTP association has between 1 and 65536 uni-directional streams in each
direction. The number of streams can be different in each direction. Every
user message is sent on a particular stream. User messages can be sent un-ordered, 
or ordered upon request by the upper layer. Un-ordered messages can be
delivered as soon as they are completely received. Ordered messages sent on
the same stream are delivered at the receiver in the same order as sent by the
sender. For user messages not requiring fragmentation, this minimizes head of
line blocking.</t>

<t>The base protocol defined in <xref target="RFC4960"/> does not allow interleaving of user-
messages. Large messages on one stream can therefore block the sending of user
messages on other streams. <xref target="I-D.ietf-tsvwg-sctp-ndata"/> overcomes this
limitation. This draft also specifies multiple algorithms for the sender side
selection of which streams to send data from, supporting a variety of
scheduling algorithms including priority based methods. The stream re-
configuration extension defined in <xref target="RFC6525"/> allows streams to be reset
during the lifetime of an association and to increase the number of streams,
if the number of streams negotiated in the SCTP handshake becomes
insufficient.</t>

<t>Each user message sent is either delivered to
the receiver or, in case of excessive retransmissions, the association is
terminated in a non-graceful way <xref target="RFC4960"/>, similar to TCP behavior.
In addition to this reliable transfer, the partial reliability extension
<xref target="RFC3758"/> allows a sender to abandon user messages.
The application can specify the policy for abandoning user messages.</t>

<t>SCTP supports multi-homing. Each SCTP endpoint uses a list of IP-addresses and
a single port number. These addresses can be any mixture of IPv4 and IPv6
addresses. These addresses are negotiated during the handshake and the address
re-configuration extension specified in <xref target="RFC5061"/> in combination with
<xref target="RFC4895"/> can be used to change these addresses in an authenticated way
during the lifetime of an SCTP association. This allows for transport layer
mobility. Multiple addresses are used for improved resilience. If a remote
address becomes unreachable, the traffic is switched over to a reachable one,
if one exists.</t>

<t>For securing user messages, the use of TLS over SCTP has been specified in
<xref target="RFC3436"/>. However, this solution does not support all services provided
by SCTP, such as un-ordered delivery or partial reliability. Therefore,
the use of DTLS over SCTP has been specified in <xref target="RFC6083"/> to overcome these
limitations. When using DTLS over SCTP, the application can use almost all
services provided by SCTP.</t>

<t><xref target="I-D.ietf-tsvwg-natsupp"/> defines methods for endpoints and
middleboxes to provide NAT traversal for SCTP over IPv4.
For legacy NAT traversal, <xref target="RFC6951"/> defines the UDP encapsulation of
SCTP-packets. Alternatively, SCTP packets can be encapsulated in DTLS packets
as specified in <xref target="I-D.ietf-tsvwg-sctp-dtls-encaps"/>. The latter encapsulation
is used within the WebRTC context.</t>

<t>SCTP has a well-defined API, described in the next subsection.</t>

</section>
<section anchor="interface-description-4" title="Interface Description">

<t><xref target="RFC4960"/> defines an abstract API for the base protocol.
This API describes the following functions callable by the upper layer of SCTP:
Initialize, Associate, Send, Receive, Receive Unsent Message,
Receive Unacknowledged Message, Shutdown, Abort, SetPrimary, Status,
Change Heartbeat, Request Heartbeat, Get SRTT Report, Set Failure Threshold,
Set Protocol Parameters, and Destroy.
The following notifications are provided by the SCTP stack to the upper layer:
COMMUNICATION UP, DATA ARRIVE, SHUTDOWN COMPLETE, COMMUNICATION LOST,
COMMUNICATION ERROR, RESTART, SEND FAILURE, NETWORK STATUS CHANGE.</t>

<t>An extension to the BSD Sockets API is defined in <xref target="RFC6458"/> and covers:</t>

<t><list style="symbols">
  <t>the base protocol defined in <xref target="RFC4960"/>. The API allows control over
local addresses and port numbers and the primary path. Furthermore
the application has fine control about parameters like retransmission
thresholds, the path supervision parameters, the delayed acknowledgment
timeout, and the fragmentation point. The API provides a mechanism
to allow the SCTP stack to notify the application about events if the
application has requested them. These notifications provide information
about status changes of the association and each of the peer addresses.
In case of send failures, including drop of messages sent unreliably, 
the application can also be notified and user
messages can be returned to the application. When sending user messages,
the stream id, a payload protocol identifier, an indication whether ordered
delivery is requested or not. These parameters can also be provided on
message reception. Additionally a context can be provided when sending,
which can be use in case of send failures. The sending of arbitrary large
user messages is supported.</t>
  <t>the SCTP Partial Reliability extension defined in <xref target="RFC3758"/> to specify
for a user message the PR-SCTP policy and the policy specific parameter.
Examples of these policies defined in <xref target="RFC3758"/> and <xref target="RFC7496"/> are:</t>
  <t>Limiting the time a user message is dealt with by the sender.</t>
  <t>Limiting the number of retransmissions for each fragment of a user message.
If the number of retransmissions is limited to 0, one gets a service similar
to UDP.</t>
  <t>Abandoning messages of lower priority in case of a send buffer shortage.</t>
  <t>the SCTP Authentication extension defined in <xref target="RFC4895"/> allowing to manage
the shared keys, the HMAC to use, set the chunk types which are only accepted
in an authenticated way, and get the list of chunks which are accepted by the
local and remote end point in an authenticated way.</t>
  <t>the SCTP Dynamic Address Reconfiguration extension defined in <xref target="RFC5061"/>.
It allows to manually add and delete local addresses for SCTP associations
and the enabling of automatic address addition and deletion. Furthermore
the peer can be given a hint for choosing its primary path.</t>
</list></t>

<t>For the following SCTP protocol extensions the BSD Sockets API extension is
defined in the document specifying the protocol extensions:</t>

<t><list style="symbols">
  <t>the SCTP Stream Reconfiguration extension defined in <xref target="RFC6525"/>.
The API allows to trigger the reset operation for incoming and
outgoing streams and the whole association. It provides also a way
to notify the association about the corresponding events. Furthermore
the application can increase the number of streams.</t>
  <t>the UDP Encapsulation of SCTP packets extension defined in <xref target="RFC6951"/>.
The API allows the management of the remote UDP encapsulation port.</t>
  <t>the SCTP SACK-IMMEDIATELY extension defined in <xref target="RFC7053"/>.
The API allows the sender of a user message to request the receiver to
send the corresponding acknowledgment immediately.</t>
  <t>the additional PR-SCTP policies defined in <xref target="RFC7496"/>.
The API allows to enable/disable the PR-SCTP extension,
choose the PR-SCTP policies defined in the document and provide statistical
information about abandoned messages.</t>
</list></t>

<t>Future documents describing SCTP protocol extensions are expected to describe
the corresponding BSD Sockets API extension in a <spanx style="verb">Socket API Considerations</spanx>
section.</t>

<t>The SCTP socket API supports two kinds of sockets:</t>

<t><list style="symbols">
  <t>one-to-one style sockets (by using the socket type <spanx style="verb">SOCK_STREAM</spanx>).</t>
  <t>one-to-many style socket (by using the socket type <spanx style="verb">SOCK_SEQPACKET</spanx>).</t>
</list></t>

<t>One-to-one style sockets are similar to TCP sockets, there is a 1:1 relationship
between the sockets and the SCTP associations (except for listening sockets).
One-to-many style SCTP sockets are similar to unconnected UDP sockets, where there
is a 1:n relationship between the sockets and the SCTP associations.</t>

<t>The SCTP stack can provide information to the applications about state
changes of the individual paths and the association whenever they occur.
These events are delivered similar to user messages but are specifically
marked as notifications.</t>

<t>New functions have been introduced to support the use of
multiple local and remote addresses.
Additional SCTP-specific send and receive calls have been defined to permit
SCTP-specific information to be sent without using ancillary data
in the form of additional cmsgs.
These functions provide support for detecting partial delivery of
user messages and notifications.</t>

<t>The SCTP socket API allows a fine-grained control of the protocol behavior
through an extensive set of socket options.</t>

<t>The SCTP kernel implementations of FreeBSD, Linux and Solaris follow mostly
the specified extension to the BSD Sockets API for the base protocol and the
corresponding supported protocol extensions.</t>

</section>
<section anchor="transport-features-4" title="Transport Features">

<t>The transport features provided by SCTP are:</t>

<t><list style="symbols">
  <t>connection-oriented transport with feature negotiation and application-to-port mapping,</t>
  <t>unicast transport,</t>
  <t>port multiplexing,</t>
  <t>uni- or bidirectional communication,</t>
  <t>message-oriented delivery with durable message framing supporting multiple concurrent streams,</t>
  <t>fully reliable, partially reliable, or unreliable delivery (based on user specified policy to handle abandoned user messages) with drop notification,</t>
  <t>ordered and unordered delivery within a stream,</t>
  <t>support for stream scheduling prioritization,</t>
  <t>segmentation,</t>
  <t>user message bundling,</t>
  <t>flow control using a window-based mechanism,</t>
  <t>congestion control using methods similar to TCP,</t>
  <t>strong error detection (CRC32c),</t>
  <t>transport layer multihoming for resilience and mobility.</t>
</list></t>

</section>
</section>
<section anchor="datagram-congestion-control-protocol-dccp" title="Datagram Congestion Control Protocol (DCCP)">

<t>Datagram Congestion Control Protocol (DCCP) <xref target="RFC4340"/> is an
IETF standards track
bidirectional transport protocol that provides unicast connections of
congestion-controlled messages without providing reliability.</t>

<t>The DCCP Problem Statement describes the goals that
DCCP sought to address <xref target="RFC4336"/>: It is suitable for
applications that transfer fairly large amounts of data and that can
benefit from control over the trade off between timeliness and
reliability <xref target="RFC4336"/>.</t>

<t>DCCP offers low overhead, and many characteristics
common to UDP, but can avoid &ldquo;re-inventing the wheel&rdquo;
each time a new multimedia application emerges.
Specifically it includes core transport functions (feature
negotiation, path state management, RTT calculation,
PMTUD, etc.): DCCP applications select how they send packets
and, where suitable, choose common algorithms to
manage their functions.
Examples of applications that can benefit from such transport services
include interactive applications,
streaming media, or on-line games <xref target="RFC4336"/>.</t>

<section anchor="protocol-description-5" title="Protocol Description">

<t>DCCP is a connection-oriented datagram protocol, providing a three-way
handshake to allow a client and server to set up a connection,
and mechanisms for orderly completion and immediate teardown of
a connection.</t>

<t>A DCCP protocol instance can be extended <xref target="RFC4340"/> and tuned using
additional features. Some features are sender-side only, requiring no
negotiation with the receiver; some are receiver-side only; and some are
explicitly negotiated during connection setup.</t>

<t>DCCP uses a Connect packet to initiate a session, and permits each endpoint 
to choose the features it wishes to support.
Simultaneous open <xref target="RFC5596"/>, as in TCP, can enable interoperability in the
presence of middleboxes. The Connect packet includes a Service Code
<xref target="RFC5595"/> that identifies the application or
protocol using DCCP, providing middleboxes with information about the
intended use of a connection.</t>

<t>The DCCP service is unicast-only.</t>

<t>It provides multiplexing to multiple sockets at each endpoint using
port numbers. An active DCCP session is identified by its four-tuple
of local and remote IP addresses and local port and remote port numbers.</t>

<t>The protocol segments data into messages, typically sized to
fit in IP packets, but which may be fragmented providing they
are smaller than the maximum packet size.
A DCCP interface allows applications to
request fragmentation for packets larger than PMTU, but not
larger than the maximum packet size allowed by the current
congestion control mechanism (CCMPS) <xref target="RFC4340"/>.</t>

<t>Each message is identified by a sequence number. The sequence number is used
to identify segments in acknowledgments, to detect unacknowledged segments, to
measure RTT, etc. The protocol may support unordered delivery of
data, and does not itself provide retransmission. DCCP supports reduced
checksum coverage, a partial payload protection mechanism similar to UDP-Lite. There
is also a Data Checksum option, which when enabled, contains a strong CRC, to
enable endpoints to detect application data corruption.</t>

<t>Receiver flow control is supported, which limits the amount of unacknowledged
data that can be outstanding at a given time.</t>

<t>DCCP supports negotiation of the congestion control profile between endpoints, 
to provide plug-and-play congestion control mechanisms. 
Examples of specified profiles include
&ldquo;TCP-like&rdquo; <xref target="RFC4341"/>, &ldquo;TCP-friendly&rdquo; <xref target="RFC4342"/>, and &ldquo;TCP-friendly for
small packets&rdquo; <xref target="RFC5622"/>. Additional mechanisms are recorded in an IANA
registry.</t>

<t>A lightweight UDP-based encapsulation (DCCP-UDP) has been defined <xref target="RFC6773"/>
that permits DCCP to be used over paths where DCCP is not natively supported.
Support for DCCP in NAPT/NATs is defined in <xref target="RFC4340"/> and <xref target="RFC5595"/>.
Upper layer protocols specified on top of DCCP include DTLS <xref target="RFC5595"/>, RTP
<xref target="RFC5672"/>, ICE/SDP <xref target="RFC6773"/>.</t>

</section>
<section anchor="interface-description-5" title="Interface Description">

<t>Functions expected for a DCCP API include: Open, Close and Management of
the progress a DCCP connection. The Open function provides feature
negotiation, selection of an appropriate CCID for congestion control and
other parameters associated with the DCCP connection. A function allows an
application to send DCCP datagrams, including setting the required
checksum coverage, and any required options. (DCCP permits sending
datagrams with a zero-length payload.) A function allows reception of
data, including indicating if the data was used or dropped. Functions can
also make the status of a connection visible to an application, including
detection of the maximum packet size and the ability to perform flow control by
detecting a slow receiver at the sender.</t>

<t>There is no API currently specified in the RFC Series.</t>

</section>
<section anchor="transport-features-5" title="Transport Features">

<t>The transport features provided by DCCP are:</t>

<t><list style="symbols">
  <t>unicast transport,</t>
  <t>connection-oriented communication with feature negotiation and application-to-port mapping,</t>
  <t>signaling of application class for middlebox support (implemented using Service Codes),</t>
  <t>port multiplexing,</t>
  <t>uni-or bidirectional communication,</t>
  <t>message-oriented delivery,</t>
  <t>unreliable delivery with drop notification,</t>
  <t>unordered delivery,</t>
  <t>flow control (implemented using the slow receiver function)</t>
  <t>partial and full payload error detection (with optional strong integrity check).</t>
</list></t>

</section>
</section>
<section anchor="transport-layer-security-tls-and-datagram-tls-dtls-as-a-pseudotransport" title="Transport Layer Security (TLS) and Datagram TLS (DTLS) as a pseudotransport">

<t>Transport Layer Security (TLS) <xref target="RFC5246"/>}
and Datagram TLS (DTLS) <xref target="RFC6347"/>} are IETF protocols that
provide several security-related features to applications. TLS is designed to
run on top of a reliable streaming transport protocol (usually TCP), while
DTLS is designed to run on top of a best-effort datagram protocol (UDP or DCCP
<xref target="RFC5238"/>). At the time of writing, the current version of TLS is 1.2; which is
defined in <xref target="RFC5246"/>. DTLS provides nearly identical functionality to
applications; it is defined in <xref target="RFC6347"/> and its current version is also
1.2.  The TLS protocol evolved from the Secure Sockets Layer (SSL) protocols
developed in the mid-1990s to support protection of HTTP traffic.</t>

<t>While older versions of TLS and DTLS are still in use, they provide weaker
security guarantees. <xref target="RFC7457"/> outlines important attacks on TLS and DTLS.
<xref target="RFC7525"/> is a Best Current Practices (BCP) document that describes secure
configurations for TLS and DTLS to counter these attacks. The recommendations
are applicable for the vast majority of use cases.</t>

<section anchor="protocol-description-6" title="Protocol Description">

<t>Both TLS and DTLS provide the same security features and can thus be discussed
together. The features they provide are:</t>

<t><list style="symbols">
  <t>Confidentiality</t>
  <t>Data integrity</t>
  <t>Peer authentication (optional)</t>
  <t>Perfect forward secrecy (optional)</t>
</list></t>

<t>The authentication of the peer entity can be omitted; a common web use case is
where the server is authenticated and the client is not. TLS also provides a
completely anonymous operation mode in which neither peer&rsquo;s identity is
authenticated. It is important to note that TLS itself does not specify how a
peering entity&rsquo;s identity should be interpreted.  For example, in the common
use case of authentication by means of an X.509 certificate, it is the
application&rsquo;s decision whether the certificate of the peering entity is
acceptable for authorization decisions.</t>

<t>Perfect forward secrecy, if enabled
and supported by the selected algorithms, ensures that traffic encrypted and
captured during a session at time t0 cannot be later decrypted at time t1 (t1 
&gt; t0), even if the long-term secrets of the communicating peers are later
compromised.</t>

<t>As DTLS is generally used over an unreliable datagram transport such as UDP,
applications will need to tolerate lost, re-ordered, or duplicated datagrams.
Like TLS, DTLS conveys application data in a sequence of independent records.
However, because records are mapped to unreliable datagrams, there are several
features unique to DTLS that are not applicable to TLS:</t>

<t><list style="symbols">
  <t>Record replay detection (optional).</t>
  <t>Record size negotiation (estimates of PMTU and record size expansion factor).</t>
  <t>Coveyance of IP don&rsquo;t fragment (DF) bit settings by application.</t>
  <t>An anti-DoS stateless cookie mechanism (optional).</t>
</list></t>

<t>Generally, DTLS follows the TLS design as closely as possible.
To operate over datagrams, DTLS includes a sequence number and limited forms
of retransmission and fragmentation for its internal operations.
The sequence number may be used for detecting replayed information, according
to the windowing procedure described in Section 4.1.2.6 of <xref target="RFC6347"/>.
DTLS forbids the use of stream ciphers, which are essentially incompatible
when operating on independent encrypted records.</t>

</section>
<section anchor="interface-description-6" title="Interface Description">

<t>TLS is commonly invoked using an API provided by packages such as OpenSSL,
wolfSSL, or GnuTLS. Using such APIs entails the manipulation of several
important abstractions, which fall into the following categories: long-term
keys and algorithms, session state, and communications/connections. There may
also be special APIs required to deal with time and/or random numbers, both of
which are needed by a variety of encryption algorithms and protocols.</t>

<t>Considerable care is required in the use of TLS APIs to ensure creation of a secure
application.  The programmer should have at least a basic understanding of encryption
and digital signature algorithms and their strengths, public key infrastructure (including
X.509 certificates and certificate revocation), and the sockets API.
See <xref target="RFC7525"/> and <xref target="RFC7457"/>, as mentioned above.</t>

<t>As an example, in the case of OpenSSL, the primary abstractions are the
library itself and method (protocol), session, context, cipher and connection.
After initializing the library and setting the method, a cipher suite is
chosen and used to configure a context object. Session objects may then be
minted according to the parameters present in a context object and associated
with individual connections. Depending on how precisely the programmer wishes
to select different algorithmic or protocol options, various levels of details
may be required.</t>

</section>
<section anchor="transport-features-6" title="Transport Features">

<t>Both TLS and DTLS employ a layered architecture. The lower layer is commonly
called the record protocol. It is responsible for:</t>

<t><list style="symbols">
  <t>message fragmentation,</t>
  <t>authentication and integrity via message authentication codes (MAC),</t>
  <t>data encryption,</t>
  <t>scheduling transmission using the underlying transport protocol.</t>
</list></t>

<t>DTLS augments the TLS record protocol with:</t>

<t><list style="symbols">
  <t>ordering and replay protection, implemented using sequence numbers.</t>
</list></t>

<t>Several protocols are layered on top of the record protocol.  These include
the handshake, alert, and change cipher spec protocols.  There is also the
data protocol, used to carry application traffic. The handshake protocol is
used to establish cryptographic  and compression parameters when a connection
is first set up.  In DTLS, this protocol also has a basic fragmentation and
retransmission capability and a cookie-like mechanism to resist DoS attacks.
(TLS compression is not recommended at present). The alert protocol is used to
inform the peer of various conditions, most of which are terminal for the
connection. The change cipher spec protocol is used to synchronize changes in
cryptographic parameters for each peer.</t>

<t>The data protocol, when used with an appropriate cipher, provides:</t>

<t><list style="symbols">
  <t>authentication of one end or both ends of a connection,</t>
  <t>confidentiality,</t>
  <t>cryptographic integrity protection.</t>
</list></t>

<t>Both TLS and DTLS are unicast-only.</t>

</section>
</section>
<section anchor="realtime-transport-protocol-rtp" title="Realtime Transport Protocol (RTP)">

<t>RTP provides an end-to-end network transport service, suitable for
applications transmitting real-time data, such as audio, video or
data, over multicast or unicast transport services, including TCP, UDP,
UDP-Lite, DCCP, TLS and DTLS.</t>

<section anchor="protocol-description-7" title="Protocol Description">

<t>The RTP standard <xref target="RFC3550"/> defines a pair of protocols, RTP and 
the RTP control protocol, RTCP. The transport does not provide connection setup,
instead relying on out-of-band techniques or associated control protocols to
setup, negotiate parameters or tear down a session.</t>

<t>An RTP sender encapsulates audio/video data into RTP packets to transport
media streams. The RFC-series specifies RTP payload formats that allow packets to
carry a wide range of media, and specifies a wide range of multiplexing, error
control and other support mechanisms.</t>

<t>If a frame of media data is large, it will be fragmented into several RTP
packets. Likewise, several small frames may be bundled into a single RTP packet.</t>

<t>An RTP receiver collects RTP packets from the network, validates them for
correctness, and sends them to the media decoder input-queue. Missing packet
detection is performed by the channel decoder. The play-out buffer is ordered
by time stamp and is used to reorder packets. Damaged frames may be repaired
before the media payloads are decompressed to display or store the data.
Some uses of RTP are able to exploit the partial payload protection features
offered by DCCP and UDP-Lite.</t>

<t>RTCP is a control protocol that works alongside an RTP flow. Both the RTP
sender and receiver will send RTCP report packets. This is used to periodically
send control information and report performance. Based on received RTCP
feedback, an RTP sender can adjust the transmission, e.g., perform rate
adaptation at the application layer in the case of congestion.</t>

<t>An RTCP receiver report (RTCP RR) is returned to the sender
periodically to report key parameters (e.g, the fraction of packets
lost in the last reporting interval, the cumulative number of
packets lost, the highest sequence number received, and the
inter-arrival jitter). The RTCP RR packets also contain timing
information that allows the sender to estimate the network
round trip time (RTT) to the receivers.</t>

<t>The interval between reports sent from each receiver tends
to be on the order of a few seconds on average, although
this varies with the session rate, and sub-second reporting
intervals are possible for high rate sessions.
The interval is randomized to avoid synchronization of
reports from multiple receivers.</t>

</section>
<section anchor="interface-description-7" title="Interface Description">

<t>There is no standard application programming interface defined for RTP or
RTCP. Implementations are typically tightly integrated with a particular
application, and closely follow the principles of application level framing
and integrated layer processing <xref target="ClarkArch"/> in media processing <xref target="RFC2736"/>,
error recovery and concealment, rate adaptation, and security <xref target="RFC7202"/>.
Accordingly, RTP implementations tend to be targeted at particular application
domains (e.g., voice-over-IP, IPTV, or video conferencing), with a feature set
optimized for that domain, rather than being general purpose implementations
of the protocol.</t>

</section>
<section anchor="transport-features-7" title="Transport Features">

<t>The transport features provided by RTP are:</t>

<t><list style="symbols">
  <t>unicast, multicast or IPv4 broadcast (provided by lower layer protocol),</t>
  <t>port multiplexing (provided by lower layer protocol),</t>
  <t>uni- or bidirectional communication (provided by lower layer protocol),</t>
  <t>message-oriented delivery with support for media types and other extensions,</t>
  <t>reliable delivery when using erasure coding or unreliable delivery with drop notification (if supported by lower layer protocol),</t>
  <t>connection setup with feature negotiation (using associated protocols) and application-to-port mapping (provided by lower layer protocol),</t>
  <t>segmentation,</t>
  <t>performance metric reporting (using associated protocols).</t>
</list></t>

</section>
</section>
<section anchor="hypertext-transport-protocol-http-over-tcp-as-a-pseudotransport" title="Hypertext Transport Protocol (HTTP) over TCP as a pseudotransport">

<t>The Hypertext Transfer Protocol (HTTP) is an application-level protocol widely
used on the Internet. It provides object-oriented delivery of discrete data or files.
Version 1.1 of the protocol is specified in <xref target="RFC7230"/>
<xref target="RFC7231"/> <xref target="RFC7232"/> <xref target="RFC7233"/> <xref target="RFC7234"/> <xref target="RFC7235"/>, and version 2 in
<xref target="RFC7540"/>.  HTTP is usually transported over TCP using port 80 and 443,
although it can be used with other transports. When used over TCP it inherits
its properties.</t>

<t>Application layer protocols may use HTTP as a substrate with an existing method
and data formats, or specify new methods and data formats. There are
various reasons for this practice listed in <xref target="RFC3205"/>; these include being a
well-known and well-understood protocol, reusability of existing servers and
client libraries, easy use of existing security mechanisms such as HTTP digest
authentication <xref target="RFC2617"/> and TLS <xref target="RFC5246"/>, the ability of HTTP to
traverse firewalls makes it work over many types of infrastructure, and in
cases where an application server often needs to support HTTP anyway.</t>

<t>Depending on application need, the use of HTTP as a substrate protocol may add
complexity and overhead in comparison to a special-purpose protocol (e.g.,
HTTP headers, suitability of the HTTP security model, etc.). <xref target="RFC3205"/>
addresses this issue and provides some guidelines and identifies
concerns about the use
of HTTP standard port 80 and 443, the use of HTTP URL scheme and interaction
with existing firewalls, proxies and NATs.</t>

<t>Representational State Transfer (REST) <xref target="REST"/> is another example of how
applications can use HTTP as transport protocol. REST is an architecture style
that may be used to build applications using HTTP as a communication
protocol.</t>

<section anchor="protocol-description-8" title="Protocol Description">

<t>Hypertext Transfer Protocol (HTTP) is a request/response protocol. A client
sends a request containing a request method, URI and protocol version followed
by a MIME-like message (see <xref target="RFC7231"/> for the differences between an HTTP
object and a MIME message), containing information about the client and
request modifiers. The message can also contain a message body carrying application
data. 
The server responds with a status or error code followed by a
MIME-like message containing information about the server and information
about the data. This may include a message body. It is possible to
specify a data format for the message body using MIME media types <xref target="RFC2045"/>.
The protocol has additional features, some relevant
to pseudo-transport are described below.</t>

<t>Content negotiation, specified in <xref target="RFC7231"/>, is a mechanism provided by HTTP
to allow selection of a representation for a requested resource. The client and server
negotiate acceptable data formats, character sets, data encoding (e.g., data can be
transferred compressed using gzip). HTTP can accommodate exchange of
messages as well as data streaming (using chunked transfer encoding
<xref target="RFC7230"/>). It is also possible to request a part of a resource using an
object range request <xref target="RFC7233"/>. The protocol provides powerful cache
control signaling defined in <xref target="RFC7234"/>.</t>

<t>The persistent connections of HTTP 1.1 and HTTP 2.0 allow multiple request-
response transactions (streams) during the life-time of a single HTTP
connection. HTTP 2.0 connections can multiplex many request/response pairs in
parallel on a single transport connection. This reduces overhead during
connection establishment and mitigates transport layer slow-start that would
have otherwise been incurred for each transaction. Both are important to
reduce latency for HTTP&rsquo;s primary use case.</t>

<t>HTTP can be combined with security mechanisms, such as TLS (denoted by HTTPS).
This adds protocol properties provided by such a mechanism (e.g.,
authentication, encryption). The TLS Application-Layer Protocol Negotiation
(ALPN) extension <xref target="RFC7301"/> can be used to negotiate the HTTP version within
the TLS handshake, eliminating the latency incurred by additional round-trip
exchanges. Arbitrary cookie strings, included as part of the MIME headers, are
often used as bearer tokens in HTTP.</t>

</section>
<section anchor="interface-description-8" title="Interface Description">

<t>There are many HTTP libraries available exposing different APIs. The APIs
provide a way to specify a request by providing a URI, a method, request
modifiers and optionally a request body. For the response, callbacks can be
registered that will be invoked when the response is received. If TLS is used,
the API exposes a registration of callbacks for a server that requests client
authentication and when certificate verification is needed.</t>

<t>The World Wide Web Consortium (W3C) has standardized the XMLHttpRequest API <xref target="XHR"/>.
This API can be used for sending HTTP/HTTPS requests and receiving server
responses. Besides the XML data format, the request and response data format can also
be JSON, HTML, and plain text. JavaScript and XMLHttpRequest are
ubiquitous programming models for websites, and more general applications,
where native code is less attractive.</t>

</section>
<section anchor="transport-features-8" title="Transport features">

<t>The transport features provided by HTTP, when used as a pseudo-transport, are:</t>

<t><list style="symbols">
  <t>unicast transport (provided by the lower layer protocol, usually TCP),</t>
  <t>uni- or bidirectional communication,</t>
  <t>transfer of objects in multiple streams with object content type negotiation, supporting partial transmission of object ranges,</t>
  <t>ordered delivery (provided by the lower layer protocol, usually TCP),</t>
  <t>fully reliable delivery (provided by the lower layer protocol, usually TCP),</t>
  <t>flow control (provided by the lower layer protocol, usually TCP).</t>
  <t>congestion control (provided by the lower layer protocol, usually TCP).</t>
</list></t>

<t>HTTPS (HTTP over TLS) additionally provides the following features (as provided by TLS):</t>

<t><list style="symbols">
  <t>authentication (of one or both ends of a connection),</t>
  <t>confidentiality,</t>
  <t>integrity protection.</t>
</list></t>

</section>
</section>
<section anchor="file-delivery-over-unidirectional-transportasynchronous-layered-coding-reliable-multicast-flutealc" title="File Delivery over Unidirectional Transport/Asynchronous Layered Coding Reliable Multicast (FLUTE/ALC)">

<t>FLUTE/ALC is an IETF standards track protocol specified in <xref target="RFC6726"/>
and <xref target="RFC5775"/>. It provides object-oriented delivery of discrete data 
or files.
Asynchronous Layer Coding (ALC) provides an underlying
reliable transport service and FLUTE a file-oriented specialization
of the ALC service (e.g., to carry associated metadata). The
<xref target="RFC6726"/> and <xref target="RFC5775"/> protocols are non-backward-compatible updates
of the <xref target="RFC3926"/> and <xref target="RFC3450"/> experimental protocols; these
experimental protocols are currently largely deployed in the 3GPP
Multimedia Broadcast and Multicast Services (MBMS) (see <xref target="MBMS"/>,
section 7) and similar contexts (e.g., the Japanese ISDB-Tmm standard).</t>

<t>The FLUTE/ALC protocol has been designed to support massively scalable
reliable bulk data dissemination to receiver groups of arbitrary size using IP
Multicast over any type of delivery network, including unidirectional networks
(e.g., broadcast wireless channels). However, the FLUTE/ALC protocol also
supports point-to-point unicast transmissions.</t>

<t>FLUTE/ALC bulk data dissemination has been designed for discrete file or
memory-based &ldquo;objects&rdquo;. Although FLUTE/ALC is not well adapted to byte- and
message-streaming, there is an exception: FLUTE/ALC is used to carry 3GPP
Dynamic Adaptive Streaming over HTTP (DASH) when scalability is a requirement
(see <xref target="MBMS"/>, section 5.6).</t>

<t>FLUTE/ALC&rsquo;s reliability, delivery mode, congestion control, and flow/rate
control mechanisms can be separately controlled
to meet different application needs. Section 4.1 of <xref target="I-D.ietf-tsvwg-rfc5405bis"/>
describes multicast congestion control requirements for UDP.</t>

<section anchor="protocol-description-9" title="Protocol Description">

<t>The FLUTE/ALC protocol works on top of UDP (though it could work on top of any
datagram delivery transport protocol), without requiring any connectivity from
receivers to the sender. Purely unidirectional networks are therefore
supported by FLUTE/ALC. This guarantees scalability to an
unlimited number of receivers in a session, since
the sender behaves exactly the same regardless of the number of receivers.</t>

<t>FLUTE/ALC supports the transfer of bulk objects such as file or in-memory
content, using either a push or an on-demand mode. in push mode, content is
sent once to the receivers, while in on-demand mode, content is sent
continuously during periods of time that can greatly exceed the average time
required to download the session objects (see <xref target="RFC5651"/>, section 4.2).</t>

<t>This enables receivers to join a session asynchronously, at their own
discretion, receive the content and leave the session.  In this case, data
content is typically sent continuously, in loops (also known as &ldquo;carousels&rdquo;).
FLUTE/ALC also supports the
transfer of an object stream, with loose real-time constraints. This is
particularly useful to carry 3GPP DASH when scalability is a requirement and
unicast transmissions over HTTP cannot be used (<xref target="MBMS"/>, section 5.6).  In
this case, packets are sent in sequence using push mode. FLUTE/ALC is
not well adapted to byte- and message-streaming and other solutions could be
preferred (e.g., FECFRAME <xref target="RFC6363"/> with real-time flows).</t>

<t>The FLUTE file delivery instantiation of ALC provides a metadata delivery
service. Each object of the FLUTE/ALC session is described in a dedicated
entry of a File Delivery Table (FDT), using an XML format (see <xref target="RFC6726"/>,
section 3.2).  This metadata can include, but is not restricted to, a URI
attribute (to identify and locate the object), a media type attribute, a size
attribute, an encoding attribute, or a message digest attribute. Since the
set of objects sent within a session can be dynamic, with new objects being
added and old ones removed, several instances of the FDT can be sent and a
mechanism is provided to identify a new FDT Instance.</t>

<t>Error detection and verification of the protocol
control information relies on the on the underlying transport (e.g., UDP checksum).</t>

<t>To provide robustness against packet loss and improve the
efficiency of the on-demand mode, FLUTE/ALC relies on packet erasure
coding (AL-FEC). AL-FEC encoding is proactive (since
there is no feedback and therefore no (N)ACK-based retransmission) and ALC
packets containing repair data are sent along with ALC packets containing
source data. Several FEC Schemes have been standardized; FLUTE/ALC does
not mandate the use of any particular one.  Several strategies concerning the
transmission order of ALC source and repair packets are possible, in
particular in on-demand mode where it can deeply impact the service provided
(e.g., to favor the recovery of objects in sequence, or at the other extreme,
to favor the recovery of all objects in parallel), and FLUTE/ALC does not
mandate nor recommend the use of any particular one.</t>

<t>A FLUTE/ALC session is composed of one or more channels, associated to
different destination unicast and/or multicast IP addresses.  ALC packets are
sent in those channels at a certain transmission rate, with a rate that often
differs depending on the channel.  FLUTE/ALC does not mandate nor recommend
any strategy to select which ALC packet to send on which channel.  FLUTE/ALC
can use a multiple rate congestion control building block (e.g., WEBRC) to
provide congestion control that is feedback free, where receivers adjust their
reception rates individually by joining and leaving channels associated with
the session.  To that purpose, the ALC header provides a specific field to
carry congestion control specific information.  However FLUTE/ALC does not
mandate the use of a particular congestion control mechanism although WEBRC is
mandatory to support for the Internet (<xref target="RFC6726"/>, section 1.1.4).
FLUTE/ALC is often used over a network path with pre-provisioned capacity
<xref target="I-D.ietf-tsvwg-rfc5405bis"/> where there are no flows competing for
capacity. In this
case, a sender-based rate control mechanism and a single channel is
sufficient.</t>

<t><xref target="RFC6584"/> provides per-packet authentication, integrity, and anti-replay
protection in the context of the ALC and NORM protocols.  Several mechanisms are
proposed that seamlessly integrate into these protocols using the ALC and
NORM header extension mechanisms.</t>

</section>
<section anchor="interface-description-9" title="Interface Description">

<t>The FLUTE/ALC specification does not describe a specific application
programming interface (API) to control protocol operation.</t>

<t>Open source reference implementations of FLUTE/ALC are available at
http://planete-bcast.inrialpes.fr/ (no longer maintained) and
http://mad.cs.tut.fi/ (no longer maintained), and these implementations
specify and document their own APIs.  Commercial versions are also available,
some derived from the above implementations, with their own API.</t>

</section>
<section anchor="transport-features-9" title="Transport Features">

<t>The transport features provided by FLUTE/ALC are:</t>

<t><list style="symbols">
  <t>unicast, multicast, anycast or IPv4 broadcast transmission,</t>
  <t>object-oriented delivery of discrete data or files and associated metadata,</t>
  <t>fully reliable or partially reliable delivery (of file or in-memory objects), using proactive packet erasure coding (AL-FEC) to recover from packet erasures,</t>
  <t>ordered or unordered delivery (of file or in-memory objects),</t>
  <t>error detection (based on the UDP checksum),</t>
  <t>per-packet authentication,</t>
  <t>per-packet integrity,</t>
  <t>per-packet replay protection,</t>
  <t>congestion control for layered flows (e.g., with WEBRC).</t>
</list></t>

</section>
</section>
<section anchor="nack-oriented-reliable-multicast-norm" title="NACK-Oriented Reliable Multicast (NORM)">

<t>NORM is an IETF standards track protocol specified in <xref target="RFC5740"/>. 
It provides object-oriented delivery of discrete data or files.</t>

<t>The protocol was designed to support reliable bulk data dissemination to receiver
groups using IP Multicast but also provides for point-to-point unicast
operation.  Support for bulk data dissemination includes discrete file or
computer memory-based &ldquo;objects&rdquo; as well as byte- and message-streaming.</t>

<t>NORM can incorporate packet erasure coding as a part of its
selective ARQ in response to negative acknowledgments from the receiver. The packet
erasure coding can also be proactively applied for forward protection from
packet loss. NORM transmissions are governed by the TCP-friendly congestion
control. The reliability, congestion control and flow control mechanisms
can be separately controlled to meet different application needs.</t>

<section anchor="protocol-description-10" title="Protocol Description">

<t>The NORM protocol is encapsulated in UDP datagrams and thus provides
multiplexing for multiple sockets on hosts using port numbers. For loosely
coordinated IP Multicast, NORM is not strictly connection-oriented although
per-sender state is maintained by receivers for protocol operation.
<xref target="RFC5740"/> does not specify a handshake protocol for connection establishment.
Separate session initiation can be used to coordinate port numbers.
However, in-band &ldquo;client-server&rdquo; style connection establishment can be
accomplished with the NORM congestion control signaling messages using port
binding techniques like those for TCP client-server connections.</t>

<t>NORM supports bulk &ldquo;objects&rdquo; such as file or in-memory content but also can
treat a stream of data as a logical bulk object for purposes of packet erasure
coding. In the case of stream transport, NORM can support either byte streams
or message streams where application-defined message boundary information is
carried in the NORM protocol messages. This allows the receiver(s) to 
join/re-join and recover message boundaries mid-stream as needed. Application 
content is carried and identified by the NORM protocol with encoding symbol
identifiers depending upon the Forward Error Correction (FEC) Scheme
<xref target="RFC3452"/> configured. NORM uses NACK-based selective ARQ to reliably deliver
the application content to the receiver(s). NORM proactively measures round-trip 
timing information to scale ARQ timers appropriately and to support
congestion control. For multicast operation, timer-based feedback suppression
is uses to achieve group size scaling with low feedback traffic levels. The
feedback suppression is not applied for unicast operation.</t>

<t>NORM uses rate-based congestion control based upon the TCP-Friendly Rate
Control (TFRC) <xref target="RFC4324"/> principles that are also used in DCCP <xref target="RFC4340"/>.
NORM uses control messages to measure RTT and collect congestion event 
information (e.g., reflecting a
loss event or ECN event) from the receiver(s) to support
dynamic adjustment or the rate. The TCP-Friendly Multicast Congestion Control
(TFMCC) <xref target="RFC4654"/> provides extra features to support multicast, but
is functionally equivalent to TFRC for unicast.</t>

<t>Error detection and verification of the protocol
control information relies on the on the underlying transport(e.g., UDP checksum).</t>

<t>The reliability mechanism is decoupled from congestion control. This allows
invocation of alternative arrangements of transport services. For example,
to support,
fixed-rate reliable delivery or unreliable delivery (that may optionally
be &ldquo;better than best effort&rdquo; via packet erasure coding) using TFRC. 
Alternative congestion control
techniques may be applied. For example, TFRC rate control with congestion
event detection based on ECN.</t>

<t>While NORM provides NACK-based reliability, it also supports a positive
acknowledgment (ACK) mechanism that can be used for receiver flow control.
This mechanism is decoupled from the reliability and congestion
control, supporting applications with different needs. One example is 
use of NORM for quasi-reliable
delivery, where timely delivery of newer content may be favored over completely
reliable delivery of older content within buffering and RTT constraints.</t>

</section>
<section anchor="interface-description-10" title="Interface Description">

<t>The NORM specification does not describe a specific application programming
interface (API) to control protocol operation. A freely-available, open source
reference implementation of NORM is available at
https://www.nrl.navy.mil/itd/ncs/products/norm, and a documented API is
provided for this implementation. While a sockets-like API is not currently
documented, the existing API supports the necessary functions for that to be
implemented.</t>

</section>
<section anchor="transport-features-10" title="Transport Features">

<t>The transport features provided by NORM are:</t>

<t><list style="symbols">
  <t>unicast or multicast transport,</t>
  <t>unidirectional communication,</t>
  <t>stream-oriented delivery in a single stream or object-oriented delivery of in-memory data or file bulk content objects,</t>
  <t>fully reliable (NACK-based) or partially reliable (using erasure coding both proactively and as part of ARQ) delivery,</t>
  <t>unordered delivery,</t>
  <t>error detection (relies on UDP checksum),</t>
  <t>segmentation,</t>
  <t>data bundling (using Nagle&rsquo;s algorithm),</t>
  <t>flow control (timer-based and/or ack-based),</t>
  <t>congestion control (also supporting fixed rate reliable or unreliable delivery).</t>
</list></t>

</section>
</section>
<section anchor="internet-control-message-protocol-icmp" title="Internet Control Message Protocol (ICMP)">

<t>The Internet Control Message Protocol (ICMP) <xref target="RFC0792"></xref> for IPv4 and
ICMP for IPv6 <xref target="RFC4433"></xref> are IETF standards track protocols.
It is a connection-less unidirectional protocol that delivers individual
messages, without error correction, congestion control, or flow control. 
Messages may be sent as unicast, IPv4 broadcast or multicast datagrams
(IPv4 and IPv6), in addition to anycast datagrams.</t>

<t>Transport Protocols and upper layer protocols can use received ICMP messages to help
them take appropriate decisions when network or endpoint errors are reported.
For example, to implement, ICMP-based Path MTU discovery <xref target="RFC1191"/><xref target="RFC1981"/>
or assist in Packetization Layer Path MTU Discovery (PMTUD) <xref target="RFC4821"/>. Such
reactions to received messages need to protect from off-path data injection
<xref target="I-D.ietf-tsvwg-rfc5405bis"/>, to avoid an application receiving packets created 
by an unauthorized third party. An application therefore needs to
ensure that all messages are appropriately validated, by checking the payload
of the messages to ensure these are received in response to actually
transmitted traffic (e.g., a reported error condition that corresponds to a
UDP datagram or TCP segment was actually sent by the application). This
requires context <xref target="RFC6056"/>, such as local state about communication
instances to each destination (e.g., in the TCP, DCCP, or SCTP protocols).
This state is not always maintained by UDP-based applications <xref target="I-D.ietf-tsvwg-rfc5405bis"/>.</t>

<section anchor="protocol-description-11" title="Protocol Description">

<t>ICMP is a connection-less unidirectional protocol, It delivers independent messages, 
called datagrams.
Each message is required to carry a checksum as an integrity check and to
protect from mis-delivery to an unintended endpoint.</t>

<t>ICMP messages typically relay diagnostic information from an endpoint
<xref target="RFC1122"/> or network device <xref target="RFC1716"/> addressed to the sender of a flow.
This usually contains the network protocol header of a packet that encountered
a reported issue. Some formats of messages can also carry other payload
data. Each message carries an integrity check calculated in the same way as
for UDP, this checksum is not optional.</t>

<t>The RFC series defines additional IPv6 message formats to support a range of uses.
In the case of IPv6 the protocol incorporates neighbor discovery <xref target="RFC2461"/> <xref target="RFC3971"/>}
(provided by ARP for IPv4) and the Multicast Listener
Discovery (MLD) <xref target="RFC2710"/> group management functions (provided by IGMP for IPv4).</t>

<t>Reliable transmission can not be assumed. A receiving application that is
unable to run sufficiently fast, or frequently, may miss messages since there
is no flow or congestion control. In addition some network devices rate-limit
ICMP messages.</t>

</section>
<section anchor="interface-description-11" title="Interface Description">

<t>ICMP processing is integrated in many connection-oriented transports,
but like other functions needs to be provided by an upper-layer protocol
when using UDP and UDP-Lite.</t>

<t>On some stacks, a bound socket also allows a UDP application to be notified
when ICMP error messages are received for its transmissions
<xref target="I-D.ietf-tsvwg-rfc5405bis"/>.</t>

<t>Any response to ICMP error messages ought to be robust to temporary
routing failures (sometimes called &ldquo;soft errors&rdquo;), e.g., transient ICMP
&ldquo;unreachable&rdquo; messages ought to not normally cause a communication abort
<xref target="RFC5461"/> <xref target="I-D.ietf-tsvwg-rfc5405bis"/>.</t>

</section>
<section anchor="transport-features-11" title="Transport Features">

<t>ICMP does not provide any transport service directly to applications. Used
together with other transport protocols, it provides transmission of control,
error, and measurement data between endpoints, or from devices along the path
to one endpoint.</t>

</section>
</section>
</section>
<section anchor="congestion-control" title="Congestion Control">

<t>Congestion control is critical to the stable operation of the Internet. A
variety of mechanisms are used to provide the congestion control needed
by many Internet transport protocols. Congestion is detected based on sensing of
network conditions, whether through explicit or implicit feedback. The
congestion control mechanisms that can be applied by different transport
protocols are largely orthogonal to the choice of transport protocol. This
section provides an overview of the congestion control mechanisms available to
the protocols described in <xref target="existing-transport-protocols"/>.</t>

<t>Many protocols use a separate window to determine the maximum sending rate
that is allowed by the congestion control. The used congestion control
mechanism will increase the congestion window if feedback is received that
indicates that the currently used network path is not congested, and will
reduce the window otherwise. Window-based mechanisms often increase their
window slowing over multiple RTTs, while decreasing strongly when the first
indication of congestion is received. One example is an Additive Increase
Multiplicative Decrease (AIMD) scheme, where the window is increased by a
certain number of packets/bytes for each data segment that has been
successfully transmitted, while the window is multiplicatively decrease on the
occurrence of a congestion event. This can lead to a rather unstable,
oscillating sending rate, but will resolve a congestion situation quickly. TCP
New Reno <xref target="RFC5681"/> which is one of the initial proposed schemes for TCP as
well as TCP Cubic <xref target="I-D.ietf-tcpm-cubic"/> which is the default mechanism for
TCP in Linux are two examples for window-based AIMD schemes. This approach is
also used by DCCP CCID-2 for datagram congestion control.</t>

<t>Some classes of applications prefer to use a transport service that allows
sending at a more stable rate, that is slowly varied in response to
congestion. Rate-based methods offer this type of congestion control and have
been  defined based on the loss ratio and observed round trip time, such as
TFRC <xref target="RFC5348"/> and TFRC-SP <xref target="RFC4828"/>. These methods utilize a throughput
equation to determine the maximum acceptable rate. Such methods are used with
DCCP CCID-3 <xref target="RFC4342"/> and CCID-4 <xref target="RFC5622"/>, WEBRC <xref target="RFC3738"/>, and other
applications.</t>

<t>Another class of applications prefer a transport service that
yields to other (higher-priority) traffic, such as interactive transmissions.
While most traffic in the Internet uses loss-based congestion control and 
therefore need to fill the network buffers (to a certain level if 
Active Queue Management (AQM) is used), low-priority congestion control 
methods often react to changes in delay as an earlier indication of congestion. 
This approach tends to  induce less loss than a
loss-based method but does generally not compete well with loss-based traffic
across shared bottleneck links. Therefore, methods such as LEDBAT <xref target="RFC6824"/>,
are deployed in the Internet for scavenger traffic that aim to only utilize 
otherwise unused capacity.</t>

</section>
<section anchor="transport-features-12" title="Transport Features">

<t>The tables below summarize some key features to illustrate the range of
functions provided across the IETF-specified transports. <xref target="tabtp"/> considers
transports that may be directly layered over the network, and
<xref target="tabult"/> considers transports layered over another transport service.
Features that are permitted, but not required, are marked as &ldquo;Poss&rdquo; indicating that
it is possible for the transport service to offer this feature.</t>

<figure title="Summary comparison: Transport protocols" anchor="tabtp"><artwork><![CDATA[
+---------------+------+------+------+------+------+------+------+
| Feature       | TCP  | MPTCP| UDP  | UDP  | SCTP |DCCP  |ICMP  |
+---------------+------+------+------+------+------+------+------+
| Datagram      | No   | No   | Yes  | Yes  | Yes  | Yes  | Yes  |
+---------------+------+------+------+------+------+------+------+
| Conn. Oriented| Yes  | Yes  | No   | No   | Yes  | Yes  | No   |
+---------------+------+------+------+------+------+------+------+
| Reliability   | Yes  | Yes  | No   | No   | Yes  | No   | No   |
+---------------+------+------+------+------+------+------+------+
| Partial Rel.  | No   | No   | N/A  | N/A  | Poss | Yes  | N/A  |
+---------------+------+------+------+------+------+------+------+
| Corupt. Tol   | No   | No   | No   | Yes  | No   | Yes  | No   |
+---------------+------+------+------+------+------+------+------+
| Cong.Control  | Yes  | Yes  | No   | No   | Yes  | Yes  | No   |
+---------------+------+------+------+------+------+------+------+
| Endpoint      |  1   | >=1  | >=1  | >=1  | >=1  |  1   |  1   |
+---------------+------+------+------+------+------+------+------+
| Multicast Cap.| No   | No   | Yes  | Yes  | No   | No   | No   |
+---------------+------+------+------+------+------+------+------+

]]></artwork></figure>

<figure title="Upper layer transports and frameworks" anchor="tabult"><artwork><![CDATA[
+---------------+------+------+------+------+------+
| Feature       |(D)TLS| RTP  | HTTP | FLUTE| NORM |
+---------------+------+------+------+------+------+
| Datagram      | Both | Yes  | No   | No   | Both |
+---------------+------+------+------+------+------+
| Conn. Oriented| Yes  | No   | Yes  | Yes  | Yes  |
+---------------+------+------+------+------+------+
| Reliability   | Poss | No   | Yes  | Yes  | Poss |
+---------------+------+------+------+------+------+
| Partial R     | No   | Poss | No   | No   | Poss |
+---------------+------+------+------+------+------+
| Corupt. Tol   | No   | Poss | No   | No   | No   |
+---------------+------+------+------+------+------+
| Cong.Control  | N/A  | Poss | N/A  | Poss | Poss |
+---------------+------+------+------+------+------+
| Endpoint      |  1   | >=1  |  1   | >=1  | >=1  |
+---------------+------+------+------+------+------+
| Multicast Cap.| No   | Yes  | No   | Yes  | Yes  |
+---------------+------+------+------+------+------+

]]></artwork></figure>

<t>The transport protocol features described in this document could be used as a basis for defining common transport features:</t>

<t><list style="symbols">
  <t>Control Functions
  <list style="symbols">
      <t>Addressing
      <list style="symbols">
          <t>unicast (TCP, MPTCP, UDP, UDP-Lite, SCTP, DCCP, TLS, RTP, HTTP, ICMP)</t>
          <t>multicast (UDP, UDP-Lite, RTP, FLUTE/ALC, NORM). Note that, as TLS and DTLS are unicast-only, there is no widely deployed mechanism for supporting the features in the Security section below when using multicast addressing.</t>
          <t>IPv4 broadcast (UDP, UDP-Lite, ICMP)</t>
          <t>anycast (UDP, UDP-Lite). Connection-oriented protocols such as TCP and DCCP have also been deployed using anycast addressing, with the risk that routing changes may cause connection failure.</t>
        </list></t>
      <t>Association type
      <list style="symbols">
          <t>connection-oriented (TCP, MPTCP, DCCP, SCTP, TLS, RTP, HTTP, NORM)</t>
          <t>connectionless (UDP, UDP-Lite, FLUTE/ALC)</t>
        </list></t>
      <t>Multihoming support
      <list style="symbols">
          <t>resilience and mobility (MPTCP, SCTP)</t>
          <t>load-balancing (MPTCP)</t>
          <t>address family multiplexing (MPTCP, SCTP)</t>
        </list></t>
      <t>Middlebox cooperation
      <list style="symbols">
          <t>application-class signaling to middleboxes (DCCP)</t>
          <t>error condition signaling from middleboxes and routers to endpoints (ICMP)</t>
        </list></t>
      <t>Signaling
      <list style="symbols">
          <t>control information and error signaling (ICMP)</t>
          <t>application performance reporting (RTP)</t>
        </list></t>
    </list></t>
  <t>Delivery
  <list style="symbols">
      <t>Reliability
      <list style="symbols">
          <t>fully reliable delivery (TCP, MPTCP, SCTP, TLS, HTTP, FLUTE/ALC, NORM)</t>
          <t>partially reliable delivery (SCTP, NORM)
          <list style="symbols">
              <t>using packet erasure coding (RTP, FLUTE/ALC, NORM)</t>
              <t>with specified policy for dropped messages (SCTP)</t>
            </list></t>
          <t>unreliable delivery (SCTP, UDP, UDP-Lite, DCCP, RTP)
          <list style="symbols">
              <t>with drop notification to sender (SCTP, DCCP, RTP)</t>
            </list></t>
          <t>error detection
          <list style="symbols">
              <t>checksum for error detection (TCP, MPTCP, UDP, UDP-Lite, SCTP, DCCP, TLS, DTLS, FLUTE/ALC, NORM, ICMP)</t>
              <t>partial payload checksum protection (UDP-Lite, DCCP). Some uses of RTP can exploit partial payload checksum protection feature to provide a corruption tolerant transport service.</t>
              <t>checksum optional (UDP). Possible with IPv4 and in certain cases with IPv6.</t>
            </list></t>
        </list></t>
      <t>Ordering
      <list style="symbols">
          <t>ordered delivery (TCP, MPTCP, SCTP, TLS, RTP, HTTP, FLUTE)</t>
          <t>unordered delivery permitted (UDP, UDP-Lite, SCTP, DCCP, RTP, NORM)</t>
        </list></t>
      <t>Type/framing
      <list style="symbols">
          <t>stream-oriented delivery (TCP, MPTCP, SCTP, TLS, HTTP)
          <list style="symbols">
              <t>with multiple streams per association (SCTP, HTTP2)</t>
            </list></t>
          <t>message-oriented delivery (UDP, UDP-Lite, SCTP, DCCP, DTLS, RTP)</t>
          <t>object-oriented delivery of discrete data or files and associated metadata (HTTP, FLUTE/ALC, NORM)
          <list style="symbols">
              <t>with partial delivery of object ranges (HTTP)</t>
            </list></t>
        </list></t>
      <t>Directionality
      <list style="symbols">
          <t>unidirectional (TCP, UDP, UDP-Lite, SCTP, DCCP, RTP, FLUTE/ALC, NORM)</t>
          <t>bidirectional (TCP, MPTCP, SCTP, TLS, HTTP)</t>
        </list></t>
    </list></t>
  <t>Transmission control
  <list style="symbols">
      <t>flow control (TCP, MPTCP, SCTP, DCCP, TLS, RTP, HTTP)</t>
      <t>congestion control (TCP, MPTCP, SCTP, DCCP, RTP, FLUTE/ALC, NORM). Congestion control can also provided by the transport supporting an upper later transport (e.g., TLS, RTP, HTTP).</t>
      <t>segmentation (TCP, MPTCP, SCTP, TLS, RTP, HTTP, FLUTE/ALC, NORM)</t>
      <t>data/message bundling (TCP, MPTCP, SCTP, TLS, HTTP)</t>
      <t>stream scheduling prioritization (SCTP, HTTP2)</t>
      <t>endpoint multiplexing (MPTCP)</t>
    </list></t>
  <t>Security
  <list style="symbols">
      <t>authentication of one end of a connection (TLS, DTLS, FLUTE/ALC)</t>
      <t>authentication of both ends of a connection (TLS, DTLS)</t>
      <t>confidentiality (TLS, DTLS)</t>
      <t>cryptographic integrity protection (TLS, DTLS)</t>
      <t>replay protection (FLUTE/ALC, DTLS)</t>
    </list></t>
</list></t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This document has no considerations for IANA.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>This document surveys existing transport protocols and protocols providing transport-like services. Confidentiality, integrity, and authenticity are among the features provided by those services. This document does not specify any new features or mechanisms for providing these features. Each RFC referenced by this document discusses the security considerations of the specification it contains.</t>

</section>
<section anchor="contributors" title="Contributors">

<t>In addition to the editors, this document is the work of Brian Adamson,
Dragana Damjanovic, Kevin Fall, Simone Ferlin-Oliviera, Ralph Holz, Olivier
Mehani, Karen Nielsen, Colin Perkins, Vincent Roca, and Michael Tuexen.</t>

<t><list style="symbols">
  <t><xref target="multipath-tcp-mptcp"/> on MPTCP was contributed by Simone Ferlin-Oliviera (ferlin@simula.no) and Olivier Mehani (olivier.mehani@nicta.com.au)</t>
  <t><xref target="user-datagram-protocol-udp"/> on UDP was contributed by Kevin Fall (kfall@kfall.com)</t>
  <t><xref target="stream-control-transmission-protocol-sctp"/> on SCTP was contributed by Michael Tuexen (tuexen@fh-muenster.de) and Karen Nielsen (karen.nielsen@tieto.com)</t>
  <t><xref target="realtime-transport-protocol-rtp"/> on RTP contains contributions from Colin Perkins (csp@csperkins.org)</t>
  <t><xref target="file-delivery-over-unidirectional-transportasynchronous-layered-coding-reliable-multicast-flutealc"/> on FLUTE/ALC was contributed by Vincent Roca (vincent.roca@inria.fr)</t>
  <t><xref target="nack-oriented-reliable-multicast-norm"/> on NORM was contributed by Brian Adamson (brian.adamson@nrl.navy.mil)</t>
  <t><xref target="transport-layer-security-tls-and-datagram-tls-dtls-as-a-pseudotransport"/> on TLS and DTLS was contributed by Ralph Holz (ralph.holz@nicta.com.au) and Olivier Mehani (olivier.mehani@nicta.com.au)</t>
  <t><xref target="hypertext-transport-protocol-http-over-tcp-as-a-pseudotransport"/> on HTTP was contributed by Dragana Damjanovic (ddamjanovic@mozilla.com)</t>
</list></t>

</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>Thanks to Joe Touch, Michael Welzl, and the TAPS Working Group for the
comments, feedback, and discussion. This work is supported by the European
Commission under grant agreement No. 318627 mPlane and from the Horizon
2020 research and innovation program under grant agreements No. 644334 (NEAT)
and No. 688421 (MAMI). This support does not imply endorsement.</t>

</section>


  </middle>

  <back>


    <references title='Informative References'>

&RFC0768;
&RFC0792;
&RFC0793;
&RFC0896;
&RFC1122;
&RFC1191;
&RFC1716;
&RFC1981;
&RFC2018;
&RFC2045;
&RFC2460;
&RFC2461;
&RFC2617;
&RFC2710;
&RFC2736;
&RFC3168;
&RFC3205;
&RFC3260;
&RFC3436;
&RFC3450;
&RFC3452;
&RFC3550;
&RFC3738;
&RFC3758;
&RFC3828;
&RFC3926;
&RFC3971;
&RFC4324;
&RFC4336;
&RFC4340;
&RFC4341;
&RFC4342;
&RFC4433;
&RFC4654;
&RFC4820;
&RFC4821;
&RFC4828;
&RFC4895;
&RFC4960;
&RFC5061;
&RFC5097;
&RFC5246;
&RFC5238;
&RFC5348;
&RFC5461;
&RFC5595;
&RFC5596;
&RFC5622;
&RFC5651;
&RFC5672;
&RFC5740;
&RFC5775;
&RFC5681;
&RFC6056;
&RFC6083;
&RFC6093;
&RFC6525;
&RFC6347;
&RFC6356;
&RFC6363;
&RFC6458;
&RFC6584;
&RFC6726;
&RFC6773;
&RFC6824;
&RFC6897;
&RFC6935;
&RFC6936;
&RFC6951;
&RFC7053;
&RFC7202;
&RFC7230;
&RFC7231;
&RFC7232;
&RFC7233;
&RFC7234;
&RFC7235;
&RFC7301;
&RFC7323;
&RFC7414;
&RFC7457;
&RFC7496;
&RFC7525;
&RFC7540;
&I-D.ietf-tsvwg-rfc5405bis;
&I-D.ietf-tsvwg-sctp-dtls-encaps;
&I-D.ietf-tsvwg-sctp-ndata;
&I-D.ietf-tsvwg-natsupp;
&I-D.ietf-tcpm-cubic;
<reference anchor="XHR" >
  <front>
    <title>XMLHttpRequest working draft (http://www.w3.org/TR/XMLHttpRequest/)</title>
    <author initials="A." surname="van Kesteren">
      <organization></organization>
    </author>
    <author initials="J." surname="Aubourg">
      <organization></organization>
    </author>
    <author initials="J." surname="Song">
      <organization></organization>
    </author>
    <author initials="H.R.M." surname="Steen">
      <organization></organization>
    </author>
    <date year="2000"/>
  </front>
</reference>
<reference anchor="REST" >
  <front>
    <title>Architectural Styles and the Design of Network-based Software Architectures, Ph. D. (UC Irvine), Chapter 5: Representational State Transfer</title>
    <author initials="R.T." surname="Fielding">
      <organization></organization>
    </author>
    <date year="2000"/>
  </front>
</reference>
<reference anchor="POSIX" >
  <front>
    <title>IEEE Standard for Information Technology -- Portable Operating System Interface (POSIX) Base Specifications, Issue 7</title>
    <author initials="IEEE Std.1003." surname="1-2008">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="MBMS" >
  <front>
    <title>3GPP TS 26.346: Multimedia Broadcast/Multicast Service (MBMS); Protocols and codecs, release 13 (http://www.3gpp.org/DynaReport/26346.htm).</title>
    <author initials="." surname="3GPP TSG WS S4">
      <organization></organization>
    </author>
    <date year="2015"/>
  </front>
</reference>
<reference anchor="ClarkArch" >
  <front>
    <title>Architectural Considerations for a New Generation of Protocols (Proc. ACM SIGCOMM)</title>
    <author initials="D." surname="Clark">
      <organization></organization>
    </author>
    <author initials="D." surname="Tennenhouse">
      <organization></organization>
    </author>
    <date year="1990"/>
  </front>
</reference>


    </references>



  </back>
</rfc>

